«IMPORT wsdl11»
«EXTENSION edu::teco::dpws::generator::templates::wsdl»

«DEFINE deliverEvent FOR TService»
«FILE name+"_deliver_event.c"»
/* Generated file */   
#include "«name».nsmap"
#include <dpws_device.h>
#include <bitsio/read_bits_buf.h>
#include <soap.h>

struct dpws_s *_device;

«EXPAND event FOREACH port.getPortType().operation.select(e|e.input==null)-»
«ENDFILE»
«ENDDEFINE»

«DEFINE event FOR TOperation»
void
«name»_event (void *device, char * buf)
{
  struct soap soap;
  struct ws4d_subscription *subs, *next;


  _device = (struct dpws_s *)device; 

  soap_init (&soap);
  soap_set_namespaces (&soap, namespaces);
{
  char soap_action_uri[]="«output.anyAttribute.toList().select(e|e.feature.name=="Action").first().value»";
  dpws_for_each_subs (subs, next, _device,
                      soap_action_uri)
  {
    char *deliverto = dpws_subsm_get_deliveryPush_address (_device, subs);

    if (!deliverto)
      continue;

    dpws_header_gen_oneway (&soap, NULL, deliverto,
                            soap_action_uri,
                            NULL, sizeof (struct SOAP_ENV__Header));

    printf ("Sending Event to %s\n", deliverto);

    if (   soap_connect(&soap, deliverto, soap_action_uri)
        || soap_envelope_begin_out(&soap)
        || soap_putheader(&soap)
        || soap_body_begin_out(&soap) )
    {
       soap_closesock(&soap);
       soap_print_fault (&soap, stderr);
    }
   {
   	  struct READER_STRUCT reader;
      read_init(&reader, buf);
      «FOREACH this.output.getMessage().part.element AS arg»
      {
      extern void «arg.localPart»_gsoap_automata_init(struct soap *, void *);
      extern void «arg.localPart»_gsoap_automata_run(void );
      
      «arg.localPart»_gsoap_automata_init(&soap, (void*)&reader);
      «arg.localPart»_gsoap_automata_run();
      }
      «ENDFOREACH»
   }
    if (   soap_body_end_out(&soap)
        || soap_envelope_end_out(&soap)
        || soap_end_send(&soap) )
    {
       soap_closesock(&soap);
       soap_print_fault (&soap, stderr);
    }
    soap_end (&soap);
  }
}
  soap_done (&soap);
}
«ENDDEFINE»
