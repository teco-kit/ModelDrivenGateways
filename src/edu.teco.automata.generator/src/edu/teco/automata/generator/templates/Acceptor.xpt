«IMPORT Automata»
«IMPORT edu::teco::automata::generator::templates»
«EXTENSION edu::teco::automata::generator::templates::util»
«EXTENSION edu::teco::automata::generator::templates::AcceptorUtil»

«DEFINE root FOR Automata::StateMachine»
   «initQueries()»
   «FILE "Acceptor.java"»
      package edu.teco.automata.generator.gen;
      import java.io.IOException;
      import edu.teco.automata.generator.core.BitsIO;
      import edu.teco.automata.generator.types.TypesBin;
      «getImports()»
      
      public class Acceptor {
         private BitsIO io;
         private int       label;
         
         public Acceptor (BitsIO io) {
            this.io = io;
         }
         
         public void run() throws IOException {
            «clear()»
            «resetCase()»
            «FOREACH states AS st»
               «EXPAND initNeeded FOR st»
            «ENDFOREACH»
            while(true)
            {
            switch (label)
            {
            «clear()»
            «resetCase()»
            «FOREACH states AS st ITERATOR i»
               «EXPAND encoderRoot::state(i.counter0) FOR st»
            «ENDFOREACH»
            «clear()»
            «resetCase()»
            }
            }
         }
      }
   «ENDFILE»
«ENDDEFINE»

«AROUND edu::teco::automata::generator::templates::encoderRoot::constLoop(Integer count) 
 FOR SimpleState»
   // constLoop «getCurrPath() + name»
   «IF isNeeded(getCurrPath() + name)»
      «IF hasCondition(getCurrPath() + name)»
         // «getCondition(getCurrPath() + name)»
         {
      «ENDIF»
      int lowB«count» = «lowerBound»;
      while (true)
      {
      if (lowB«count» <= 0)
         breatk;
      lowB«count»--;
      «targetDef.proceed()»
   «ELSE»
      // skip «count» * TypesBin.size«type.metaType.name.toFirstUpper()»
   «ENDIF»
«ENDAROUND»

«AROUND edu::teco::automata::generator::templates::encoderRoot::constLoopEnd(String endName) 
FOR State»
   // constLoopEnd «endName»
   «IF isNeeded(endName)»
      «targetDef.proceed()»
   «ENDIF»
«ENDAROUND»

«AROUND edu::teco::automata::generator::templates::encoderRoot::loop(Integer count) 
FOR SimpleState»
   // loop «getCurrPath() + name»
   «IF isNeeded(getCurrPath() + name)»
      «IF hasCondition(getCurrPath() + name)»
         // «getCondition(getCurrPath() + name)»
         {
      «ENDIF»
      /* loop «getCurrPath() + name» */
      while(io.read_bit())
      { /* depth «depth» */
      «targetDef.proceed()»
   «ELSE»
      // skip TypesBin.size «type.metaType.name.toFirstUpper()»
   «ENDIF»
«ENDAROUND»

«AROUND edu::teco::automata::generator::templates::encoderRoot::loopEnd(String endName) 
FOR State»
   // loopEnd «endName»
   «IF isNeeded(endName)»
      «targetDef.proceed()»
   «ENDIF»
«ENDAROUND»

«AROUND edu::teco::automata::generator::templates::encoderRoot::complexLoop(Integer count, Integer label) FOR SimpleState»
   «IF isNeeded(getCurrPath() + name)»
      «IF hasCondition(getCurrPath() + name)»
         // «getCondition(getCurrPath() + name)»
         {
      «ENDIF»
   if(io.read_bit())
   { /* depth «depth»*/
   «targetDef.proceed()»
   }
   else
   {
      label = «getEndCase(name)» ;
      continue;
   } /* «name» */
   «ENDIF»
«ENDAROUND»

«AROUND edu::teco::automata::generator::templates::encoderRoot::complexConstLoop(Integer count, Integer label) FOR SimpleState» 
   «IF isNeeded(getCurrPath() + name)»
     «IF hasCondition(getCurrPath() + name)»
         // «getCondition(getCurrPath() + name)»
         {
      «ENDIF»
   if(io.read_bit())
   { /* depth «depth»*/
   «targetDef.proceed()»
   }
   else
   {
      label = «getEndCase(name)»;
      continue;
   } /* «name» */
   «ENDIF»
«ENDAROUND»

«AROUND edu::teco::automata::generator::templates::encoderRoot::stateNameBegin 
FOR SimpleState»

«ENDAROUND»

«AROUND edu::teco::automata::generator::templates::encoderRoot::stateNameEnd 
FOR SimpleState»
   «REM»
      System.out.println("</«name»>");
   «ENDREM»
«ENDAROUND»

«AROUND edu::teco::automata::generator::templates::encoderRoot::statePapaEnd 
FOR State»
   //statePapaEnd «getPapaName()»
   «IF isNeeded(getPapaName())»
      «targetDef.proceed()»
   «ELSE»
      «popStack()»   
   «ENDIF»
«ENDAROUND»

«AROUND edu::teco::automata::generator::templates::encoderRoot::statePapaNameEnd 
FOR State»
   «REM»
      System.out.println("</«getPapaName()»>");
   «ENDREM»
«ENDAROUND»

«AROUND edu::teco::automata::generator::templates::encoderRoot::stateType 
FOR SimpleState»
   // stateType «getCurrPath() + name»
   «IF isNeeded(getCurrPath() + name)»
      «IF hasAction(getCurrPath() + name)»
         «getAction(getCurrPath() + name, type.metaType.name)»
      «ENDIF»
   «ENDIF»
«ENDAROUND»


«REM» 
Implementing this with Xpand is not such a good idea
«ENDREM»
«DEFINE initNeeded FOR SimpleState»
   // initNeeded «name»
   «IF ! isStackEmpty()»
   «IF getPapaDepth() >= depth»
      «IF isCurrNeeded()»
         «EXPAND stIterator(getSize()-1)»
      «ELSE»
         «popStack()»
      «ENDIF»
   «ENDIF»
   «ENDIF» 
   «IF type.metaType.name == complexTypeName()»
      «pushType(name, depth, lowerBound, upperBound, kind, lowerBound)»
   «ELSE»
      «IF isNeeded(getCurrPath() + name)»
         // setNeeded «getCurrPath() + name»
         «setCurrNeeded(true)»
         «setNeeded(getCurrPath() + name, true)»
      «ENDIF»
   «ENDIF»
«ENDDEFINE»

«DEFINE initNeeded FOR StopState»
   «IF ! isStackEmpty()»
      «EXPAND stIterator(getSize()-1)»
   «ENDIF»
«ENDDEFINE»

«DEFINE initNeeded FOR State»
«ENDDEFINE»

«DEFINE stIterator(Integer count) FOR State»
   // stIterator «name»
   // setNeeded2 «getPapaName()» «isCurrNeeded()»
   «setNeeded(getPapaName(), isCurrNeeded())»
   «popStack()»
   «IF count > 0»
      «EXPAND stIterator(count-1)»
   «ELSE»
      «setCurrNeeded(false)»
   «ENDIF»
«ENDDEFINE»
