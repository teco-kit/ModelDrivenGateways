«IMPORT Automata»
«EXTENSION edu::teco::automata::generator::templates::util»
«EXTENSION edu::teco::automata::generator::templates::AcceptorUtil»

«DEFINE root FOR StateMachine»
   «FOREACH states AS st ITERATOR i»
      «EXPAND encoderRoot::state(i.counter0) FOR st»
   «ENDFOREACH»
«ENDDEFINE»

«DEFINE state(Integer count) FOR SimpleState»
   «IF ! isStackEmpty()»
      «IF getParentDepth() >= depth»
         «EXPAND stateParentEnd»
      «ENDIF»
   «ENDIF»
   «IF type.metaType.name == complexTypeName()»
      «LET getNextCase() AS label»
      «EXPAND stateParentBegin(count, label)»
      « IF lowerBound == upperBound »
         « IF lowerBound != 1 »
            «EXPAND complexConstLoop(count, label)»
         « ELSE »
            « EXPAND stateNameBegin »
            « pushType(name, depth, lowerBound, upperBound, kind, label) »
         « ENDIF »
      « ELSE »
         « EXPAND complexLoop(count, label) »
      « ENDIF »
      «EXPAND stateEnd»
      «ENDLET»
   «ELSE»
      «EXPAND stateBegin(count)»
      « IF lowerBound == upperBound »
         « IF lowerBound != 1 »
            «EXPAND constLoop(count)»
            «EXPAND constLoopEnd(name)»
         « ELSE  »
            « EXPAND stateNameBegin »
            « EXPAND stateType      »
            « EXPAND stateNameEnd   »
         « ENDIF »
      « ELSE »
         « EXPAND loop(count)  »
         « EXPAND loopEnd(name)»
      « ENDIF »
      «EXPAND stateEnd»
   «ENDIF»
«ENDDEFINE»

«DEFINE state(Integer count) FOR StartState»
// Start State
«ENDDEFINE»

«DEFINE state(Integer count) FOR StopState»
   «IF ! isStackEmpty()»
      «EXPAND stackItr(getSize()-1)»
   «ENDIF»
   «EXPAND StateBegin»
   «EXPAND StateEnd»
«ENDDEFINE»
  

«DEFINE state(Integer count) FOR State»
«REM»Should not be executed«ENDREM»
«ENDDEFINE»

«DEFINE stackItr(Integer count) FOR StopState»
   «EXPAND stateParentEnd»
   «IF count > 0»
      «EXPAND stackItr(count-1)»
   «ENDIF»
«ENDDEFINE»

«REM» 
========================================================================
Stack initializer 
needs to be called at beginning of each template
«ENDREM»
«DEFINE initNeeded FOR SimpleState»
   «incCase()»
   «IF ! isStackEmpty()»
      «IF getParentDepth() >= depth»
         «IF isCurrNeeded()»
            «EXPAND stIterator(depth)»
         «ELSE»
            «popStack()»
         «ENDIF»
      «ENDIF»
   «ENDIF» 
   «IF type.metaType.name == complexTypeName()»
      «pushType(name, depth, lowerBound, upperBound, kind, lowerBound)»
   «ELSE»
      «IF isNeeded(getCurrPath() + name)»
         «setCurrNeeded(true)»
         «setNeeded(getCurrPath() + name, true)»
      «ENDIF»
   «ENDIF»
«ENDDEFINE»

«DEFINE initNeeded FOR StopState»
   «IF ! isStackEmpty()»
      «EXPAND stIterator(-1)»
   «ENDIF»
«ENDDEFINE»

«DEFINE initNeeded FOR State»
«ENDDEFINE»

«DEFINE stIterator(Integer depth) FOR State»
   «LET getNextCase() AS label»
   «setEndCase(getParentName(), label)»
   «setNeeded(getParentName(), isCurrNeeded())»
   «popStack()»
   «ENDLET»
   «IF ! isStackEmpty()»
   «IF getParentDepth() >= depth»
      «EXPAND stIterator(depth)»
   «ELSE»
      «setCurrNeeded(false)»
   «ENDIF»
   «ENDIF»
«ENDDEFINE»

«REM»
The one below are define separate in order to enable 
easy AROUND statements.
«ENDREM»

«DEFINE loop(Integer count) FOR SimpleState»
   « EXPAND stateNameBegin »
   « EXPAND stateType      »
   « EXPAND stateNameEnd   »
«ENDDEFINE»

«DEFINE loopEnd(String endName) FOR State»
   } /* «endName» */
«ENDDEFINE»

«DEFINE constLoop(Integer count) FOR SimpleState»
   « EXPAND stateNameBegin »
   « EXPAND stateType      »
   « EXPAND stateNameEnd   »
«ENDDEFINE»

«DEFINE constLoopEnd(String endName) FOR State»
   } /* constLoopEnd «endName» */
«ENDDEFINE»

«DEFINE complexLoop(Integer count, Integer label) FOR SimpleState»
   « EXPAND stateNameBegin »   
   « pushType(name, depth, lowerBound, upperBound, kind, label) »
«ENDDEFINE»

«DEFINE complexLoopEnd1(String endName) FOR State»
   label = «getBeginCase()»; /* constLoopEnd1 «endName» */
«ENDDEFINE»

«DEFINE complexLoopEnd2(String endName) FOR State»
   continue; /* constLoopEnd2 «endName» */
«ENDDEFINE»


«DEFINE complexConstLoop(Integer count, Integer label) FOR SimpleState»
   « EXPAND stateNameBegin »
   « pushType(name, depth, lowerBound, upperBound, kind, label) »
«ENDDEFINE»

«DEFINE complexConstLoopEnd1(String endName) FOR State»
   label = «getBeginCase()»; /* complexLoopEnd1 «endName» */
«ENDDEFINE»

«DEFINE complexConstLoopEnd2(String endName) FOR State»
   continue;  /* complexLoopEnd2 «endName» */
«ENDDEFINE»

«DEFINE stateNameBegin FOR SimpleState»
   «IF kind != "attribute"-»
      «IF out.get(0).metaType.name == "Automata::SimpleState"-»
         «IF ((Automata::SimpleState)out.get(0)).kind != "attribute"-»
      out.println("<«name»>");
         «ELSE»
      out.print("<«name»");
         «ENDIF»
      «ELSE»
      out.println("<«name»>");
      «ENDIF»
   «ELSE»
      out.print(" «name»=\"");
   «ENDIF»
«ENDDEFINE»

«DEFINE stateNameEnd FOR SimpleState»
   «IF kind != "attribute"-»
   out.println("</«name»>");
   «ELSE-»
      out.print("\"");
      «IF out.get(0).metaType.name == "Automata::SimpleState"-»
         «IF ((Automata::SimpleState)out.get(0)).kind != "attribute"-»
         out.println(">");
         «ENDIF»
      «ENDIF»
   «ENDIF»
«ENDDEFINE»

«DEFINE stateParentEnd FOR State»
   case «getNextCase()»:  //stateParentEnd(«name») : «getLowB()»..«getUpB()»
   {
    «IF getLowB() != 1 || getUpB() != 1»
      «IF getLowB() == getUpB()» «REM» TODO «ENDREM»
      «EXPAND complexConstLoopEnd1(getCurrParentPath())»
      «ELSE»
      «EXPAND complexLoopEnd1(getCurrParentPath())»
      «ENDIF»
    «ELSE»
    label++; 
   «ENDIF»
   «EXPAND stateParentNameEnd»
   «IF getLowB() != getUpB() || getLowB() != 1»
      «IF getLowB() == getUpB()»
      «EXPAND complexConstLoopEnd2(getCurrParentPath())»
      «ELSE»
      «EXPAND complexLoopEnd2(getCurrParentPath())»
      «ENDIF»
   «ENDIF»
   } /* case */
   «popStack()»
«ENDDEFINE»

«DEFINE stateParentNameEnd FOR State»
  «IF getParentKind() != "attribute"-»
  out.println("</«getParentName()»>");
  «ENDIF»
«ENDDEFINE»

«DEFINE stateType FOR SimpleState»
  «IF kind != "attribute"-»
  out.println
  «ELSE»
  out.print
  «ENDIF»
  ( new TypesString.«getTypeMap(type.metaType.name)»().read(io) );
«ENDDEFINE»

«DEFINE stateBegin(Integer count) FOR State»
   case «getNextCase()» : //stateBegin(«name»)
   {
      label++; 
«ENDDEFINE»

«DEFINE stateEnd FOR State»
   } /* stateEnd */
«ENDDEFINE»

«DEFINE stateParentBegin(Integer count, Integer label) FOR State»
   case «label» ://stateParentBegin(«name»)
   {
   label++;
«ENDDEFINE»

«DEFINE StateBegin FOR StopState»
 default: //StopState
«ENDDEFINE»

«DEFINE StateEnd FOR StopState»
 return;
«ENDDEFINE»
