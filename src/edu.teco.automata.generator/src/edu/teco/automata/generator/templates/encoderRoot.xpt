«IMPORT Automata»
«EXTENSION edu::teco::automata::generator::templates::util»
«EXTENSION edu::teco::automata::generator::templates::AcceptorUtil»

«DEFINE root FOR StateMachine»
   «FOREACH states AS st ITERATOR i»
      «EXPAND encoderRoot::state(i.counter0) FOR st»
   «ENDFOREACH»
«ENDDEFINE»


«DEFINE state(Integer count) FOR SimpleState»

   «IF ! isStackEmpty()»
      «IF getParent().depth >= depth» «REM»leaving state«ENDREM»
         «EXPAND stateComplexEnd(getCurrParentPath()) FOR getParent()»
      «ENDIF»
   «ENDIF»   
   
   «IF type.metaType == complexType»   
      «LET getNextCase() AS next»
      
      «EXPAND stateComplexBegin(count, next)»      
       
      «IF lowerBound == upperBound » «REM»fixed number of elements«ENDREM»
         « IF lowerBound == 1 » 
           «EXPAND complexBegin(next)»
         « ELSE »
           «EXPAND complexConstLoopBegin(count, next)»
         « ENDIF »
      « ELSE »
           « EXPAND complexLoopBegin(count, next) »
      « ENDIF »
      
      «EXPAND stateEnd»
      
      «ENDLET»
   «ELSE»
   
      «EXPAND stateBegin(count)»      
      
      « IF lowerBound == upperBound »
         « IF lowerBound != 1 »
            «EXPAND constLoopBegin(count)»
            «EXPAND constLoopEnd(name)»
         « ELSE »
         	«EXPAND simpleBegin(count)»
         	«EXPAND simpleEnd»
         « ENDIF »
      « ELSE »
         « EXPAND loopBegin(count)  »
         « EXPAND loopEnd(name)»
      « ENDIF »
      
      «EXPAND stateEnd»
   «ENDIF»
   
«ENDDEFINE»


«DEFINE state(Integer count) FOR StartState»
// Start State
«ENDDEFINE»

«DEFINE state(Integer count) FOR StopState»
   «IF ! isStackEmpty()»
      «EXPAND stackItr(getSize()-1)»
   «ENDIF»
   «EXPAND StateBegin»
   «EXPAND StateEnd»
«ENDDEFINE»
  

«DEFINE state(Integer count) FOR State»
«REM»Should not be executed«ENDREM»
«ENDDEFINE»

«DEFINE stackItr(Integer count) FOR StopState»
   «EXPAND stateComplexEnd(getCurrParentPath()) FOR getParent()»
   «IF count > 0»
      «EXPAND stackItr(count-1)»
   «ENDIF»
«ENDDEFINE»

«REM» 
========================================================================
Stack initializer 
needs to be called at beginning of each template
«ENDREM»

«DEFINE initNeeded FOR SimpleState»
   «incCase()»
   «IF ! isStackEmpty()»
      «LET getParent() AS parent»
      «IF parent.depth >= depth»
      «EXPAND stIterator(depth)»
      «REM»
         «IF isCurrNeeded()»
            «EXPAND stIterator(depth)»
         «ELSE»
            «ERROR "Why not"+ name»
            «popStack()»
         «ENDIF»
        «ENDREM»
      «ENDIF»
   «ENDLET»
   «ENDIF» 
   
   «IF type.metaType == complexType»
      «pushType(lowerBound)»
   «REM»  «pushType(name, depth, lowerBound, upperBound, kind, lowerBound?????)» «ENDREM»
   «ELSE»
      «IF isNeeded(getCurrPath() + name)»
         «setCurrNeeded(true)»
         «setNeeded(getCurrPath() + name, true)»
      «ENDIF»
   «ENDIF»
«ENDDEFINE»

«DEFINE initNeeded FOR StopState»
   «IF ! isStackEmpty()»
      «EXPAND stIterator(-1)»
   «ENDIF»
«ENDDEFINE»

«DEFINE initNeeded FOR State»
«ENDDEFINE»

«DEFINE stIterator(Integer depth) FOR State»
   «LET getNextCase() AS label»
   «setEndCase(getParent(), label)»
   «setNeeded(getParent().name, isCurrNeeded())»
   «popStack()»
   «ENDLET»
   «IF ! isStackEmpty()»
   «IF getParent().depth >= depth»
      «EXPAND stIterator(depth)»
   «ELSE»
      «setCurrNeeded(false)»
   «ENDIF»
   «ENDIF»
«ENDDEFINE»

«REM»
The one below are define separate in order to enable 
easy AROUND statements.
«ENDREM»

«REM»============state============«ENDREM»

«DEFINE stateBegin(Integer count) FOR SimpleState»
   case «getNextCase()» : //stateBegin(«name»)
   {
      label++; 
«ENDDEFINE»

«DEFINE stateBegin FOR StartState»
   case «getNextCase()» : //stateBegin(«getCurrPath()»)
   {
      label++; 
«ENDDEFINE»

«DEFINE StateBegin FOR StopState»
 default: //StopState
«ENDDEFINE»

«DEFINE StateEnd FOR StopState»
 return;
«ENDDEFINE»

«DEFINE stateEnd FOR State»
	 break;
   } /* stateEnd */
«ENDDEFINE»


«DEFINE stateNameBegin FOR SimpleState»
//stateNameBegin «name»
«ENDDEFINE»

«DEFINE stateNameEnd FOR SimpleState»
//stateNameEnd «name»
«ENDDEFINE»

«DEFINE stateType FOR SimpleState»
// stateType «getTypeMap(type.metaType.name)»
«ENDDEFINE»

«REM»============stateComplex============«ENDREM»

«DEFINE stateComplexBegin(Integer count, Integer label) FOR SimpleState»
   case «label» ://stateComplexBegin(«name»)
   {
   label++;
«ENDDEFINE»

«DEFINE stateComplexEnd(String path) FOR SimpleState» 
   case «getNextCase()»:  //stateComplexEnd(«name») : «lowerBound»..«upperBound»
   {
    «IF lowerBound != 1 || upperBound != 1»«REM» TODO: why is this split into 2 ends??? «ENDREM»
      «IF lowerBound == upperBound» 
      «EXPAND complexConstLoopEnd1(path)»
      «ELSE»
      «EXPAND complexLoopEnd1(path)»
      «ENDIF»
    «ELSE»
      «EXPAND complexEnd»
   «ENDIF»
   
   «EXPAND stateNameEnd»
   
   «IF lowerBound != upperBound || lowerBound != 1»
      «IF lowerBound == upperBound»
      «EXPAND complexConstLoopEnd2(path)»
      «ELSE»
      «EXPAND complexLoopEnd2(path)»
      «ENDIF»
   «ELSE»
   break;
   «ENDIF»
   } /* case */
   «popStack()»
«ENDDEFINE»

«REM»==== simpleElement  ====«ENDREM»

«DEFINE simpleBegin(Integer label) FOR SimpleState»
{
               « EXPAND stateNameBegin »
   			   « EXPAND stateType      »
   			   « EXPAND stateNameEnd   »
«ENDDEFINE»

«DEFINE simpleEnd FOR SimpleState»
}
«ENDDEFINE»

«REM»==== loop ====«ENDREM»

«DEFINE loopBegin(Integer count) FOR SimpleState»
  {
   « EXPAND stateNameBegin »
   « EXPAND stateType      »
   « EXPAND stateNameEnd   »
«ENDDEFINE»

«DEFINE loopEnd(String endName) FOR SimpleState»
   } /* «endName» */
«ENDDEFINE»

«REM»==== constLoop ====«ENDREM»

«DEFINE constLoopBegin(Integer count) FOR SimpleState»
 /* constLoopBegin «name» */{ 
   « EXPAND stateNameBegin »
   « EXPAND stateType      »
   « EXPAND stateNameEnd   »
«ENDDEFINE»

«DEFINE constLoopEnd(String endName) FOR SimpleState»
   } /* constLoopEnd «endName» */
«ENDDEFINE»

«REM»==== complexElement  ====«ENDREM»

«DEFINE complexBegin(Integer label) FOR SimpleState»
            « EXPAND stateNameBegin »
            « pushType(label) »
«ENDDEFINE»

«DEFINE complexEnd FOR SimpleState»
     label++; «REM»TODO: is this always correct??«ENDREM»
«ENDDEFINE»

«REM»==== complexLoop  ====«ENDREM»

«DEFINE complexLoopBegin(Integer count, Integer label) FOR SimpleState»
   « EXPAND stateNameBegin »   
   « pushType(label) »
«ENDDEFINE»

«DEFINE complexLoopEnd1(String endName) FOR SimpleState»
   label = «getBeginCase()»; /* constLoopEnd1 «endName» */
«ENDDEFINE»

«DEFINE complexLoopEnd2(String endName) FOR SimpleState»
   continue; /* constLoopEnd2 «endName» */
«ENDDEFINE»

«REM»==== complexConstLoop  ====«ENDREM»

«DEFINE complexConstLoopBegin(Integer count, Integer label) FOR SimpleState»
   « EXPAND stateNameBegin »
   « pushType(label) »
«ENDDEFINE»

«DEFINE complexConstLoopEnd1(String endName) FOR SimpleState»
   label = «getBeginCase()»; /* complexLoopEnd1 «endName» */
«ENDDEFINE»

«DEFINE complexConstLoopEnd2(String endName) FOR SimpleState»
   continue;  /* complexLoopEnd2 «endName» */
«ENDDEFINE»

«REM»============args============«ENDREM»
«DEFINE inArg FOR StateMachine»
/*in*/
«ENDDEFINE»

«DEFINE outArg FOR StateMachine»
/*out*/
«ENDDEFINE»
