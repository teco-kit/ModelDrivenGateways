/*! \mainpage WS4D-gSoap DPWS toolkit Documentation

WS4D-gSOAP is an extension of the well known gSOAP Web services
toolkit, a toolkit for building SOAP-based Web services with C/C++
developed by Robert A. van Engelen. It is designed to develop
small footprint and high throughput Web services.

WS4D-gSOAP uses a similar workflow as gSOAP. To create a DPWS device a
developer has to specify a WSDL description of the services on a
device and the device's metadata. The WSDL files are used for code
generation in gSOAP's typical way. The device metadata is used to
generate code for service setup and assignment of model metadata and
device characteristics. With the resulting code a developer can
concentrate just on the implementation of the functionality of the
services hosted on a device.

The toolkit uses gSOAP's plug-in mechanism to implement WS-Addressing,
WS-Discovery, WS-MetadataExchange / WS-Transfer and WS-Eventing on top
of gSOAP. WS4D-gSOAP supports three different roles for an endpoint
implementation that can be switched at compiletime by including a
specific header file: device (dpws_device.h), client (dpws_client.h)
and peer (dpws_peer.h). With the device role an endpoint implements
the device side of the specification. The client role is used to
create code for a Web service client, respectively. The peer role has
to be used when both client and device are about to be integrated in
one application.

WS4D-gSOAP offers multi-platform support such as the Linux i386,
Windows- native, Windows-cygwin and embedded Linux (FOX Board [Acm07]
and Nokia Maemo [Mae07]) platforms. To develop devices a typical GNU
software devel- opment toolchain can be used. Developers preferring
integrated development environments can use Visual Studio 8.0 on
Windows or Eclipse on other platforms.

There is an installation guide in the INSTALL file.

A good starting point for learning how to implement dpws devices and
clients is the \subpage tutorial_page . */

//-----------------------------------------------------------


//-----------------------------------------------------------

/*! \page tutorial_page Tutorial
\section tutIntro Introduction

This tutorial gives an introduction to the development of devices and
control points conforming to the Devices Profile for Web Services
using the WS4D gSOAP extension. During this tuturial an easy example,
was chosen to show the features of this extension.

The Devices Profile for Web Services (DPWS) standard was developed to
enable secure Web service capabilities on resource-constraint
devices. It features secure exchange of messages with Web services,
dynamic discovery and description of Web services, and subscribing to,
and receiving events from a Web service.

\image html DpwsProtocolStack.jpg
\image latex DpwsProtocolStack.pdf "The Devices Profile for Web Services protocol stack" width=10cm

    As shown in the pciture, DPWS bases on well known protocols and
several Web service specifications. It employs similiar messaging
mechanisms as the Web Services Architecture (WSA) with restrictions to
complexity and message size ([Mic06, ZBBG07]). On top of the low level
communication foundations like IP- Uni- and Multicasting, TCP and HTTP
it uses SOAP-over-UDP, SOAP, and XML Schema for the actual information
exchanges. WS-Policy, WS-Addressing and WS-Security are on top of the
messaging layer. WS-Policy is used to ex- change and negotiate
policies and parameters required for service usage. WS- Addressing
separates the SOAP messaging layer from its close binding to HTTP as
defined in the SOAP specification. It introduces the concepts of
message information headers and endpoint references making service
users, providers and transmitted messages uniquely identifiable and
addressable. The WS-Security specification defines mechanisms for
secure communication leveraging standards like XML-Encryption,
XML-Signature and Secure Sockets Layer (SSL).

    DPWS specifies further mechanisms for ad-hoc device discovery,
device and service description and eventing. Ad-hoc device discovery
is based on WS- Discovery, SOAP-over-UDP and IP-Multicast. Devices can
advertise their services to the network and clients can probe a
network for specific devices. The devices describe their
characteristics and capabilities (in form of services hosted by the
device) using the Web Service Description Language (WSDL) – as known
from the WSA – which can be used by service clients to identify and
bind to particular service interfaces. It can also be used to find out
where the services actual communication endpoints reside. Finally,
DPWS also contains a publish-subscribe mechanism (WS-Eventing) for
services acting as an event source and sending events to subscribed
clients.

The Devices Profile for Web Services (DPWS) standard is an approach to
define a standard that is fully based on Web Service standards and
offers similar functionality as UPnP.

The workflow to develop devices or clients conform to DPWS can be
split up in several phases.

 The Design of the SOA-based airconditioner device and clients used in
this tutorial can be split up in several phases. The first phase is
the definition of the device (see \ref tutDeviceDescription) and the
related service interfaces (see \ref tutInterface). Then comes the
implementation of the service (see \ref tutImplServ). And in a final
step the service is used by clients (see \ref tutImplSimplClient).
The section afterwards address specific aspects
of the plugin api and how to use them in an application.

\section simplAC Simple Airconditioner device

\subsection setUpProjEvn Setup project environment

The best way to setup project environments for projects using
WS4D-gSOAP is to use an environment based on the cmake build system.

This project environment will be configured to do a out of source tree build.
This means all code and generated files are written to another directory tree to
keep the source tree clean. This makes the work with version control systems
easier.

Create the following directory structure for your new project:

\verbatim
[Project Main Directory]
 |-- Build           (directory for out of source build)
 |-- CMakeLists.txt  (copy this file from the Airconditioner example)
 |-- buildversion    (a file containing the version of your project)
 |-- cmake-modules   (copy this direcotry from the Airconditioner example)
 |   |-- FindDPWS-C.cmake
 |   |-- FindDPWS-D.cmake
 |   |-- FindDPWS.cmake
 |   `-- FindGSOAP.cmake
 `-- src             (directory for source files)
     `-- CMakeLists.txt (empty file)
\endverbatim

You will find the airconditioner example in the installation directory of
the ws4d-gSOAP toolkit under share/doc/ws4d-gSOAP/example.

Then you have to modify CMakeLists.txt and create an empty src/CMakeLists.txt.
In CMakeLists.txt file you can modify the following part:
\verbatim
################################################################################
# Edit the parts below to use this cmake bild environment for your own projects
################################################################################

# Name of the project, language
PROJECT(AC C)

# Path to gsoap installation
SET(GSOAP_PATH "[path where gSOAP is installed]" CACHE PATH "Path where gSOAP is installed")

# Path to dpws installation
SET(DPWS_PATH "[path where ws4d-gSOAP is installed]" CACHE PATH "Path where WS4D-gSOAP is installed")
\endverbatim
Here you can specify the project name, in this case "AC" and where cmake will
find gSOAP (GSOAP_PATH) and the ws4d-gSOAP toolkit (DPWS_PATH).

Now you can test if your project environment is working:
\verbatim
$ cd Build
$ cmake ..
-- The C compiler identification is GNU
-- Check for working C compiler: /usr/bin/gcc
-- Check for working C compiler: /usr/bin/gcc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Using gnu patch: /usr/bin/patch
-- Found gSOAP in: /home/elmex/Dokumente/eclipse/gsoap-linux-2.7.10
-- Using xsltproc: /usr/bin/xsltproc
-- Found DPWS in /home/elmex/Dokumente/eclipse/dpws-core/Install-Debug
-- Looking for include files CMAKE_HAVE_PTHREAD_H
-- Looking for include files CMAKE_HAVE_PTHREAD_H - found
-- Looking for pthread_create in pthreads
-- Looking for pthread_create in pthreads - not found
-- Looking for pthread_create in pthread
-- Looking for pthread_create in pthread - found
-- Buildversion: 0.1

-- Build type not set, defaulting to DEBUG!
-- Configuring done
-- Generating done
-- Build files have been written to: /home/elmex/test/Build
\endverbatim

If you get error messages, you have to specify the correct paths to the gSOAP
and the WS4D-gSOAP installation.

\verbatim
$ cd Build
$ cmake -DGSOAP_PATH:PATH=[absolute path to gSOAP installation] -DDPWS_PATH:PATH=[absolute path to ws4d-gSOAP installation directory] ..
\endverbatim

After sucessfully calling cmake, there should be a build environment
for the platform you are working on. An a Linux oder Unix platfrom
cmake generates a build environment based on make files.

Now you can start to create the device and service description.

\subsection tutDeviceDescription Device Definition

DPWS offers device description at runtime. This description can be
defined at runtime with API functions of WS4D-gSOAP. A better approach
is to define the description at development time and use the
WS4D-gSOAP code generator to integrate the description into a device.

Here is an example description of the AirConditioner device:
\verbatim
<?xml version="1.0" encoding="ISO-8859-1"?>
<wsm:Metadata xmlns:wsm="http://schemas.xmlsoap.org/ws/2004/09/mex"
	      xmlns:acs1="http://www.ws4d.org/axis2/tutorial/AirConditioner"
	      xmlns:aces1="http://www.ws4d.org/axis2/tutorial/AirConditionerEvent"
	      xmlns:wdp="http://schemas.xmlsoap.org/ws/2006/02/devprof"
	      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	      xmlns:wsd="http://schemas.xmlsoap.org/ws/2005/04/discovery"
	      xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing"
	      xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <wsm:MetadataSection Dialect="http://schemas.xmlsoap.org/ws/2006/02/devprof/Relationship">
    <wdp:Relationship Type="http://schemas.xmlsoap.org/ws/2006/02/devprof/host">
      <wdp:Host>
        <wdp:Types>acs1:AirConditioner</wdp:Types>
        <wdp:ServiceId>DPWS-HostingService</wdp:ServiceId>
      </wdp:Host>
      <wdp:Hosted>
        <wdp:Types>acs1:AirConditionerInterface</wdp:Types>
        <wdp:ServiceId>AirConditioner</wdp:ServiceId>
        <Name>AirConditioner</Name>
      </wdp:Hosted>
    </wdp:Relationship>
  </wsm:MetadataSection>
  <wsm:MetadataSection Dialect="http://schemas.xmlsoap.org/ws/2006/02/devprof/ThisModel">
    <wdp:ThisModel>
      <wdp:Manufacturer lang="de">Universität Rostock</wdp:Manufacturer>
      <wdp:Manufacturer lang="en">University of Rostock</wdp:Manufacturer>
      <wdp:ManufacturerUrl>http://www.uni-rostock.de</wdp:ManufacturerUrl>
      <wdp:ModelName lang="de">Klimaanlagendienst</wdp:ModelName>
      <wdp:ModelName lang="en">AirConditioner Service</wdp:ModelName>
      <wdp:ModelNumber>1.0</wdp:ModelNumber>
      <wdp:ModelUrl>http://www.uni-rostock.de</wdp:ModelUrl>
    </wdp:ThisModel>
  </wsm:MetadataSection>
  <wsm:MetadataSection Dialect="http://schemas.xmlsoap.org/ws/2006/02/devprof/ThisDevice">
    <wdp:ThisDevice>
      <wdp:FriendlyName lang="de">Klimaanlagendienst</wdp:FriendlyName>
      <wdp:FriendlyName lang="en">AirConditioner Service</wdp:FriendlyName>
      <wdp:FirmwareVersion>Version 0.1</wdp:FirmwareVersion>
      <wdp:SerialNumber>234d5e4f-c23f-4d91-84ba-1f159284b37a</wdp:SerialNumber>
    </wdp:ThisDevice>
  </wsm:MetadataSection>
</wsm:Metadata>
\endverbatim

The device description consists of 3 parts: Relationship, ThisModel
and ThisDevice.

ThisModel and ThisDevice contains characteristics of the device and
the model that are device users. The Manufacturer,
ModelName and Friendlyname tags are localized strings an can be
defined in severl languages. ThisRelationship describes the
relationhship between services hosted on the device. There are Host
(hosting) services and Hosted services.

Host services take over description of their Hosted services. Host
services are classified into types specified in a Types tag. A type
should define a specific relationship between a Host service an its
Hosted services. Host services can be clearly identified on a device
by the id specified in the ServiceId tag.

Hosted services are also classified into types with a Types tag. A
type should describe which interface a service has. The best way to do
this is to use port types from WSDL files as types. Hosted services
can also be clearly identified on a device by the id specified in the
ServiceId tag.

All this information is used by the WS4D-gSOAP metadata code generator
to generate code to setup the device und all description
information. The code generator defines following functions:
 - acs_set_Metadata() : Sets the description specified in the device definition documet described above.
 - acs_setup_HostingService() : Setup the Host (hosting) service

In addition the code generator generates functions to setup hosted
services. As the ServiceId tag in hosted services can't be used as
identifier in C, a C identifier must be specified in the Name tag. The
code generator then generates functions called dpws_setup_[Identifier
in Name tag].

You should save the device description under src/metadata.xml.

\subsection tutInterface Service Definition

Having define the device description, the service description of the
Hosted services must be defined. The disgnated way of defining a
service interface is WSDL. The design of a WSDL is cumbersome as there
are only a few tools to design WSDL files. Further complication may
appear when using WSDL files with Web Services Toolkits that support
code generation of stub und skeleton code based on WSDL files.

A usable tool for creating WSDL files is the WSDL-Editor component of
the Web Tools Platform (WTP) of eclipse.

The following points for developing WSDL files should be considered:
 - the service should use document literal message format
 - WS-Addressing must be used and wsa:Action attributes must be defined for every operation input and output
 - No soapAction should be used
 - the service address tag in the binding should be empty

To use a WSDL for code generation with gSOAP it must be translated to
gSOAPs annotated c header syntax for service description. This can be
done with the wsdl2h contained in the gSOAP package.

You should save the AirConditioner WSDL file under src/AirConditioner.wsdl

\verbatim
$ wsdl2h -c -n [prefix] [WSDL file] -o [output gSOAP file]
\endverbatim

To generate the acs.gsoap file for the AirConditioner device simply call

\verbatim
$ cd src
$ wsdl2h -c -n acs AirConditioner.wsdl -o acs.gsoap

**  The gSOAP WSDL parser for C and C++ 1.2.10
**  Copyright (C) 2000-2008 Robert van Engelen, Genivia Inc.
**  All Rights Reserved. This product is provided "as is", without any warranty.
**  The gSOAP WSDL parser is released under one of the following two licenses:
**  GPL or the commercial license by Genivia Inc. Use option -l for more info.

Saving acs.gsoap

Cannot open file 'typemap.dat'
Problem reading type map file 'typemap.dat'.
Using internal type definitions for C instead.

Reading file 'AirConditioner.wsdl'
Error: no wsdl:definitions/portType/operation/input

To complete the process, compile with:
soapcpp2 acs.gsoap

\endverbatim

As gSOAP does not only generate stub und skeleton code for a web
service but also a C data binding for the data types used and defined
in a service description, it generates a lot of functions fpr the
databinding. The prefix argument defines the prefix for these data
types and functions to avoid name collisions.

As gSOAP is not aware of DPWS and the WS4D-gSOAP extension, the
translated gSOAP file must be modified by hand. First, the DPWS
specific protocols must be imported with @#import "devprof_2006_02.gsoap"

\verbatim
[...]

/******************************************************************************\
 *                                                                            *
 * Import                                                                     *
 *                                                                            *
\******************************************************************************/

#import "devprof_2006_02.gsoap"

/******************************************************************************\
 *                                                                            *
 * Schema Namespaces                                                          *
 *                                                                            *
\******************************************************************************/

[...]
\endverbatim

In addition method-action parameters of all operations must be
modified or added. This parameters are used to create the message
dispatch functions. As DPWS uses document/literal messages can only
dispatched with the WS-Addressing actions. So the method-action
parameter must be changed to the WS-Addressing action attribute in the
first input or output part of an operation.

\verbatim
[...]

//gsoap acs1 service method-style:	GetStatus document
//gsoap acs1 service method-encoding:	GetStatus literal
//gsoap acs1 service method-action:	GetStatus http://www.ws4d.org/axis2/tutorial/AirConditioner/GetStatusIn
int __acs1__GetStatus(
    struct _acs1__EmptyMessage*         acs1__GetStatus,
    struct acs1__ACStateType*           acs1__ACState	///< Response parameter
);

[...]

//gsoap acs1 service method-style:	SetTargetTemperature document
//gsoap acs1 service method-encoding:	SetTargetTemperature literal
//gsoap acs1 service method-action:	SetTargetTemperature http://www.ws4d.org/axis2/tutorial/AirConditioner/SetTargetTemperatureIn
int __acs1__SetTargetTemperature(
    int                                 acs1__TargetTemperature,	///< Request parameter
    struct acs1__ACStateType*           acs1__ACState	///< Response parameter
);

[...]
\endverbatim

You have to edit src/acs.gsoap to reflect the required modifications.

Now further modifications must be applied to the gsoap file, as the
code generated by soapcpp2 with this file won't work. There is a
problem with empty input messages (messages that go from the client to
the device. We use such an empty message in the GetStatus
operation. Normally wsdl2h would generate

\code
int __acs1__GetStatus(
    struct acs1__ACStateType*           acs1__ACState	///< Response parameter
);
\endcode

for this operation. To let soapcpp2 generate working code a empty
message must be defined in the schema types part of the gsoap file.

\verbatim
/******************************************************************************\
 *                                                                            *
 * Schema Types                                                               *
 *                                                                            *
\******************************************************************************/

struct _acs1__EmptyMessage
{
  void *_;
};
\endverbatim

This structure must be used as input message in the GetSatus
operation. So the definition of the GetStatus operation should look
like this:

\code
//gsoap acs1 service method-style:	GetStatus document
//gsoap acs1 service method-encoding:	GetStatus literal
//gsoap acs1 service method-action:	GetStatus http://www.ws4d.org/axis2/tutorial/AirConditioner/GetStatusIn
int __acs1__GetStatus(
    struct _acs1__EmptyMessage*         acs1__GetStatus,
    struct acs1__ACStateType*           acs1__ACState	///< Response parameter
);
\endcode

\subsection tutUpdate1BuildSystem Update build system

Now the directory tree of your project should look like this:

\verbatim
[Project Main Directory]
 |-- Build
 |-- CMakeLists.txt
 |-- buildversion
 |-- cmake-modules
 |   |-- FindDPWS-C.cmake
 |   |-- FindDPWS-D.cmake
 |   |-- FindDPWS.cmake
 |   `-- FindGSOAP.cmake
 `-- src
     |-- AirConditioner.wsdl
     |-- CMakeLists.txt
     |-- acs.gsoap
     `-- metadata.xml
\endverbatim

Now you have to update src/CMakeLists.txt to do the code generation
part of the build process with the new created files src/metadata.xml
src/AirConditioner.wsdl and src/acs.gsoap.

First you have to add a section that is common for all projects. The code
generation functions of ws4d-gSOAP expect a project structure that is set up
by this section.
\verbatim
################################################################################
# Common for all ws4d-gsoap projects, don't change this !
################################################################################

# directory to put all generated files in
SET(gen_DIR ${CMAKE_CURRENT_BINARY_DIR}/gen)

# If the directory for the generated sources does not
# already exists, create it.
IF(NOT EXISTS ${gen_DIR})
	FILE(MAKE_DIRECTORY ${gen_DIR})
ENDIF(NOT EXISTS ${gen_DIR})

# set include paths
INCLUDE_DIRECTORIES(${GSOAP_INCLUDE_DIR} ${DPWS_INCLUDES} ${gen_DIR})

# set options for gSOAP runtime
GSOAP_SET_RUNTIME_FLAGS("-DWITH_NONAMESPACES -DWITH_UDP")
\endverbatim

The GSOAP_SET_RUNTIME_FLAGS macro sets the gSOAP runtime flags, required
to use gSOAP with the ws4d-gSOAP toolkit.

Then we can add the section that generates the code that is needed by the
simple airconditioner device:
\verbatim
###############################################################################
###############################################################################
##                                                                           ##
## Simple airconditioner device                                              ##
##                                                                           ##
###############################################################################
###############################################################################

###############################################################################
# Code generation - for custom projects this must be modified
###############################################################################

# generate code and C data binding operations of service
GSOAP_GENERATE(acs.gsoap acs1 ${gen_DIR})   # normal service

# generate device description and setup code
DPWS_METADATA_GENERATE(metadata.xml acs ${gen_DIR})

# embed wsdl files into c code
SET(AIRCONDITIONER_WSDL ${CMAKE_CURRENT_SOURCE_DIR}/AirConditioner.wsdl)
DPWS_EMBEDD_WSDL(${gen_DIR} acs ${AIRCONDITIONER_WSDL})
\endverbatim

GSOAP_GENERATE is a cmake macro that controls the gSOAP code generator
soapcpp2. It has three parameters. The first parameter is the name of
the gSOAP file. The macro searches in the current source directory
(that would be src/ in this case) for the specified file. The second
parameter is the prefix for the stub and skeleton code to avoid c
function name collisions. The third parameter is the directory where
soapcpp2 should write the generated files.

The GSOAP_GENERATE call generates the stub and skeleton code for
the GetStatus and the SetTargetTemperature operation of the
AirConditioner service.

DPWS_METADATA_GENERATE is a cmake macro that controls the WS4D-gSOAP
code generator. This macro has three parameters. The first parameter
is the name of the device description file (metadata.xml). The macro
searches in the current source directory (that would be src/ in this
case) for the specified file. The second paramater is the prefix of
the files and functions to generate. The third parameter is the
directory where the WS4D-gSOAP code generator should write the
generated files.

DPWS_EMBEDD_WSDL is a cmake macro to embedd several WSDL files as C
character strings into a C file. The macro has a variable number of
parameters. The first parameter is the directory where the C file with
the embedded WSDLs should be written. The second parameter ist the
prefix of the files and functions to generate. The following parameter
are WSDL files with a full absolut path. This filename with path can
later be used to address a wsdl file in the embedded code. The WSDL
file names should be saved in variables to use them later in the cmake
file. We store the location where the AirConditioner.wsdl is located
on the file system to use this information later in the cmake file.

Next step will be the generation of a header file where all
configuration parameters determined at build time will be passed to
the c implementation. This can be done with a C header file with
placeholder that are replaced by cmake at configuration time.

In this case we use the location of the AirConditioner.wsdl stored int the
AIRCONDITIONER_WSDL variable.

You should create the file src/config.in.h with the following content:
\code
#ifndef @PROJECT_NAME@_CONFIG_H_
#define @PROJECT_NAME@_CONFIG_H_

#define AIRCONDITIONER_WSDL "@AIRCONDITIONER_WSDL@"

#endif /*@PROJECT_NAME@_CONFIG_H_*/
\endcode

Then you have to add the following section to the src/CMakeLists.txt
to add the configuration of config.h at build time.

\verbatim
################################################################################
# create config.h
################################################################################

CONFIGURE_FILE(${CMAKE_CURRENT_SOURCE_DIR}/config.h.in
               ${gen_DIR}/config.h
               @ONLY IMMEDIATE)
\endverbatim

This will pass the WSDL file name of the AirConditioner WSDL to the C
code. In the code we can use AIRCONDITIONER_WSDL where we need the
file name. cmake replaces the @@AIRCONDITIONER_WSDL@ with the content
of the AIRCONDITIONER_WSDL variable. In this way further variables of
the cmake build system can be pased to the C implementation of the
device.

Now we can add the part to build the simple airconditioner device:
\verbatim
################################################################################
# build simple air conditioner - for custom projects this must be modified
################################################################################

# ${simple_arcondtitioner_SRCS} defines the dependencies to build
# acs_simple_device. The device and service logic is implemented in
# simple_airconditioner.c. ${GSOAP_STDSOAP2_SOURCE} is the gSOAP runtime
# stdsoap2.c. ${gen_DIR}/acs1ServerLib.c is the skeleton code generated by
# gSOAP. The device description and setup code in ${gen_DIR}/acs_metadata.c was
# generated by WS4D-gSOAP. The AirConditioner.wsdl is embedded into
# ${gen_DIR}/acs_wsdl.c by WS4D-gSOAP.

SET(simple_arcondtitioner_SRCS
	simple_airconditioner.c
	${GSOAP_STDSOAP2_SOURCE}
	${gen_DIR}/acs1ServerLib.c
	${gen_DIR}/acs_metadata.c
	${gen_DIR}/acs_wsdl.c)

EXTEND_COMPILE_FLAGS(${simple_arcondtitioner_SRCS} FLAGS "-DDPWS_DEVICE")

# compile all files in simple_arcondtitioner_SRCS and link them into
# the acs_simple_device executable
ADD_EXECUTABLE(acs_simple_device ${simple_arcondtitioner_SRCS})

# link the device specific dpws libraries into the airconditioner executable
TARGET_LINK_LIBRARIES(acs_simple_device ${DPWS_LIBRARIES} ${DPWS-D_LIBRARIES})
\endverbatim

To create executables cmake has a macro called ADD_EXECUTABLE where
first the name of the executable and the the name of the C files, that
should be compiled and linked in the executable, is given. In this
case we have defined these files with the cmake variable
simple_arcondtitioner_SRCS.

In case of the simple airconditioner executable, following source files are
required:
 - simple_airconditioner.c: the airconditioner implementation
 - ${GSOAP_STDSOAP2_SOURCE}: the gSOAP runtime
 - ${gen_DIR}/acs1ServerLib.c: the server side code generated by soapcpp2 for the Airconditioner service
 - ${gen_DIR}/acs_metadata.c: the code generated by the WS4D-gSOAP code generator
 - ${gen_DIR}/acs_wsdl.c: the embedded WSDLs

The WS4D-gSOAP toolkit has several operation modes: client, device, peer,
hosted, threadsafe, etc. . This modes are activated by preprocessor definitions
and specific libaries.

The EXTEND_COMPILE_FLAGS cmake macro is used to define operation mode.
In this case "DPWS_DEVICE".

Libraries that must be linked to an executable are specified with a
separate macro in cmake. The macro is called TARGET_LINK_LIBRARIES and
has a targetname (in this case airconditioner) and the libraries to
link as parameter.

To use WS4D-gSOAP in device mode the libraries defined in ${DPWS_LIBRARIES}
${DPWS-D_LIBRARIES} must be linked into the binary.

Now we can create an minimal c code for an application and save it under
src/simple_airconditioner.c:
\verbatim
int main()
{
  return 0;
}
\endverbatim

The project tree should look like this:

\verbatim
[Project Main Directory]
 |-- Build
 |-- CMakeLists.txt
 |-- buildversion
 |-- cmake-modules
 |   |-- FindDPWS-C.cmake
 |   |-- FindDPWS-D.cmake
 |   |-- FindDPWS.cmake
 |   `-- FindGSOAP.cmake
 `-- src
     |-- AirConditioner.wsdl
     |-- CMakeLists.txt
     |-- acs.gsoap
     |-- config.h.in
     |-- metadata.xml
     `-- simple_airconditioner.c
\endverbatim

To test our project environment we try to build the simple airconditioner
example.
\verbatim
$ cd Build
$ make
-- Using gnu patch: /usr/bin/patch
-- Found gSOAP in: /home/elmex/Dokumente/eclipse/gsoap-linux-2.7.10
-- Found DPWS in /home/elmex/Dokumente/eclipse/dpws-core/Install-Debug
-- Buildversion: 0.1

-- Build type not set, defaulting to DEBUG!
-- Choosing target is: device - none specified
-- Configuring done
-- Generating done
-- Build files have been written to: /home/elmex/test/Build
[ 12%] Generating gen/acs_wsdl.c, gen/acs_wsdl.h
[ 25%] Generating gen/acs1ServerLib.c, gen/acs1Server.c, gen/acs1ClientLib.c, gen/acs1Client.c, gen/acs1C.c, gen/acs1H.h, gen/acs1Stub.h, gen/acs1.nsmap

**  The gSOAP Stub and Skeleton Compiler for C and C++ 2.7.10
**  Copyright (C) 2000-2008, Robert van Engelen, Genivia Inc.
**  All Rights Reserved. This product is provided "as is", without any warranty.
**  The gSOAP compiler is released under one of the following three licenses:
**  GPL, the gSOAP public license, or the commercial license by Genivia Inc.

Using project directory path: /home/elmex/test/Build/src/gen/
Saving /home/elmex/test/Build/src/gen/acs1Stub.h
Saving /home/elmex/test/Build/src/gen/acs1H.h
Saving /home/elmex/test/Build/src/gen/acs1C.c
Saving /home/elmex/test/Build/src/gen/acs1Client.c
Saving /home/elmex/test/Build/src/gen/acs1ClientLib.c
Saving /home/elmex/test/Build/src/gen/acs1Server.c
Saving /home/elmex/test/Build/src/gen/acs1ServerLib.c
Using acs1 service name: ACServiceSoap12Binding
Using acs1 service style: document
Using acs1 service encoding: literal
Using acs1 service location:
Using acs1 schema namespace: http://www.ws4d.org/axis2/tutorial/AirConditioner
Saving /home/elmex/test/Build/src/gen/acs1.nsmap namespace mapping table

Compilation successful

[ 37%] Generating gen/acs_metadata.c, gen/acs_metadata.h
Scanning dependencies of target acs_simple_device
[ 50%] Building C object src/CMakeFiles/acs_simple_device.dir/simple_airconditioner.o
[ 62%] Building C object src/CMakeFiles/acs_simple_device.dir/home/elmex/Dokumente/eclipse/gsoap-linux-2.7.10/gsoap/stdsoap2.o
[ 75%] Building C object src/CMakeFiles/acs_simple_device.dir/gen/acs1ServerLib.o
[ 87%] Building C object src/CMakeFiles/acs_simple_device.dir/gen/acs_metadata.o
[100%] Building C object src/CMakeFiles/acs_simple_device.dir/gen/acs_wsdl.o
Linking C executable ../bin/acs_simple_device
CMakeFiles/acs_simple_device.dir/gen/acs1ServerLib.o: In function `soap_serve___acs1__GetStatus':
/home/elmex/test/Build/src/gen/acs1Server.c:99: undefined reference to `__acs1__GetStatus'
CMakeFiles/acs_simple_device.dir/gen/acs1ServerLib.o: In function `soap_serve___acs1__SetTargetTemperature':
/home/elmex/test/Build/src/gen/acs1Server.c:140: undefined reference to `__acs1__SetTargetTemperature'
collect2: ld gab 1 als Ende-Status zurück
make[2]: *** [bin/acs_simple_device] Fehler 1
make[1]: *** [src/CMakeFiles/acs_simple_device.dir/all] Fehler 2
make: *** [all] Fehler 2
\endverbatim

This won't work, because gSOAP generates skeleton code that expects the
functions __acs1__GetStatus and __acs1__SetTargetTemperature. How these
functions are implemented is described in the following section.

\subsection tutImplServ Implementing the AirConditioner device

The next step is to implement a device with help of the generated
code.

First open src/simple_airconditioner.c and add the following include files:

\code
#include "acs1.nsmap"
#include "dpws_device.h"
#include "acs_metadata.h"
#include "acs_wsdl.h"
#include "config.h"
#include <signal.h>
\endcode

 - acs1.nsmap is generated by soapcpp2 and includes the namespace
table of the service and the prototypes of all generated functions und
structures. You can only include one nsmap file in every C file. If
you want implement more than one service in a device you have to
implement them in seperate C files.

 - dpws_device.h is the include file for funcitons and structures
offered by the dpws device library.

 - acs_metadata.h contains prototypes for functions to use the code
generated by WS4D-gSOAP code generator. The functions we will use in
this device are acs_setup_HostingService(), acs_setup_AirConditioner,
acs_set_Metadata and acs_update_Metadata.

 - acs_wsdl.h contains prototypes for a function acs_set_wsdl, to add
   the embedded wsdls to the device.

 - config.h contains the configuration variables set by the cmake
build system.

 - signal.h is used later to stop the device with ctrl-c.

Before the main function is implemented, a dpws handle to hold all
dpws specific information and a soap handle for the service should be
declared as global variable that all parts of the code have access to
the handles.

\code
struct soap service;
struct dpws_s device;
\endcode

Now the main function to initialize and run the device can be
implemented. At the moment WS4D-gSOAP has no logic to check it's own
IP address. the best way is to pass the IP address where the device
should operate on. This can be best done by command line.

A dpws device has a unique network indepenent id in form of a uuid
that should look like this:
\verbatim
urn:uuid:093b817d-d6d5-4d75-854f-c06355b17e31
\endverbatim

To be able to start a device several times with seperate ids, the id
is also pased by command line. Because of this the first part of the
main function consists of code to parse the command line.

\code
int
main (int argc, char **argv)
{
#ifndef WIN32
  struct sigaction sa;
#endif
  char *interface = NULL;
  char *uuid = NULL;

  /* parsing command line options */
  while (argc > 1)
    {
      if (argv[1][0] == '-')
        {
          char *option = &argv[1][1];

          switch (option[0])
            {
            case 'i': /* set interface with option -i */
              if (strlen (option) > 2)
                {
                  ++option;
                  interface = option;
                }
              else
                {
                  --argc;
                  ++argv;
                  interface = argv[1];
                }
#ifdef DEBUG
              printf ("\nAirconditioner: Set interface to \"%s\"\n", interface);
#endif
              break;
            case 'u': /* set id with option -u */
              if (strlen (option) > 2)
                {
                  ++option;
                  uuid = option;
                }
              else
                {
                  --argc;
                  ++argv;
                  uuid = argv[1];
                }
#ifdef DEBUG
              printf ("\nAirconditioner: Set uuid to \"%s\"\n", uuid);
#endif
              break;
            default:
              fprintf (stderr, "\nAirconditioner: Bad option %s\n", argv[1]);
              printf ("\n%s -i [interface address] -u urn:uuid[uuid]\n", argv[0]);
              exit(1);
            }
        }
      --argc;
      ++argv;
    }

  if (interface == NULL)
    {
      fprintf (stderr, "\nAirconditioner: No interface addrss was specified!\n");
      exit (1);
    }
\endcode

Now the previous declared soap handle should be initialized and the
namespace table should be set:

\code
  /* initialize soap handle */
  soap_init (&service);
#ifdef DEBUG
  soap_omode (&service, SOAP_XML_INDENT);
#endif
  soap_set_namespaces (&service, acs1_namespaces);
\endcode

The first function should be called for every soap handle that is used
in an device. This function initializes the soap handle for usage with
the gSOAP runtime environment. The second call is for debugging
purpose and can be omitted. soap_omode sets flags of the soap
handle. SOAP_XML_INDENT specifies that the xml code of the generated
messages should be indented which eases the reading of the messages
for debugging purpose. The third function is necessary to initialize
the namespace table of the soap handle. If this step is omitted, gSOAP
won't be able to generate valid SOAP messages.

After the gSOAP specific initialization follows the DPWS-Plugin
initialization that consists of several parts.

\code
  /* initialize device and services */
  if (dpws_init (&device, interface)
      || acs_setup_HostingService (&device, &service, uuid, 100)
      || acs_setup_AirConditioner (&device, &service, AIRCONDITIONER_WSDL,
                                   100))
    {
      fprintf (stderr, "\nAirconditioner: Can't init device and services\n");
      dpws_done (&device);
      exit (1);
    }

  /* Set Metadata */
  acs_set_Metadata (&device);
  acs_set_wsdl (&device);

  /* Update Metadata */
  if (dpws_update_Metadata (&device))
    {
      fprintf (stderr, "\nAirconditioner: Can't init metadata\n");
      dpws_done (&device);
      exit (1);
    }
\endcode

First the dpws handle, the hosting service and the AirConditioner
service are initialized and setup. The function #dpws_init is
responsible for the initialization of dpws structures and binds them
to a network device that was specified at the command line here. Then
the Hosting service is setup. This is done with the function
acs_setup_HostingService generated by the WS4D-gSOAP code
generator. This function internaly calls #dpws_add_hosting_service
which binds the hosting service at the specified soap handle, sets the
device id and adds the device types to be advertised.

The WS4D-gSOAP code generator also generates a function for each
hosted service. This functions are called [prefix]_setup_[Name specified
in the device description] which internally initializes a service with
the service id specified in the device description, binds this service
to the passed soap handle, sets the service id as specified in the
device description, registers the wsdl with the passed name and
finally registers the service at the hosting service to be advertised.

Then the acs_set_Metadata function generated by the WS4D-gSOAP code
generator sets the device and model characteristics. Afterwards the
embedded wsdls are included by calling the function acs_set_wsdl which
was generated by embedwsdl.

The last step of the dpws initialisation is to generate the static
content for the device an service description. This is done with the
acs_update_Metadata function which internally takes a snapshot of all
device and service data, and generates static messages with this
information.

Everytime the device or service description data is changed or
services are added or removed this function must be called to update
the description that is delivered to clients. This function also
triggers a mechanism that informs clients that there is a change in
the description on this device.

After all services to advertise has been registered, the services can
be served. This is done with an message processing loop. This loop
consists of an incoming message listener called #dpws_maccept, a
message dispatcher called dpws_mserve and a function that cleans up
soaps internal memory called soap_end. These three function can be
called in an infinite loop. In the time service example this loop is
only interrupted by an signal handler for SIGINT to shut the device
down by calling the service_exit function.

\code
  /* install signal handler for SIGINT or Ctrl-C */
#ifdef WIN32
  signal (SIGINT, service_exit);
#else
  memset (&sa, 0, sizeof (sa));
  sa.sa_handler = service_exit;
  sigaction (SIGINT, &sa, NULL);
#endif
\endcode

To shut the device down in a controlled manner the service_exit
function should contain the following lines.

\code
void
service_exit ()
{
#ifdef DEBUG
  printf ("\nAirconditioner: shutting down...\n");
#endif

  dpws_deactivate_hosting_service (&device);
  soap_done (&service);
  dpws_done (&device);

  exit (0);
}
\endcode

This function sould be implemented before the main function!

Before we start the message processing loop, we should tell the
hosting service to start the advertisment of its services. This is
done with the function #dpws_activate_hosting_service.

\code
  /* Tell hosting service to start advertising its hosted services */
  if (dpws_activate_hosting_service (&device))
    {
      fprintf (stderr, "\nAirconditioner: Can't activate device\n");
      dpws_done (&device);
      exit (1);
    }
\endcode

The message processing loop looks like this:

\code
#ifdef DEBUG
  printf ("\nAirconditioner: ready to serve... (Ctrl-C for shut down)\n");
#endif

  for (;;)
    {
      struct soap *handle = NULL, *soap_set[] = SOAP_HANDLE_SET (&service);
      int (*serve_requests[]) (struct soap * soap) =
        SOAP_SERVE_SET (acs1_serve_request);

#ifdef DEBUG
      printf ("\nAirconditioner: waiting for request\n");
#endif

      /* waiting for new messages */
      handle = dpws_maccept (&device, 100000, 1, soap_set);

      if (handle)
        {

#ifdef DEBUG
          printf ("\nAirconditioner: processing request from %s:%d\n",
                  inet_ntoa (handle->peer.sin_addr),
                  ntohs (handle->peer.sin_port));
#endif

          /* dispatch messages */
          if (dpws_mserve (handle, 1, serve_requests))
            {
              soap_print_fault (handle, stderr);
            }

          /* clean up soaps internaly allocated memory */
          soap_end (handle);
        }
    }

  return -1;
}
\endcode

The function #dpws_maccept takes a set of soap handles and waits for
an incomming message to one of the handles. It then accepts the
message and returns the correspondig handle. Then the message can be
processed with #dpws_mserve. This function takes a set of message
processing functions generated by soapcpp2 and tests which processing
function services the request. If the request could be served, the
internal allocated memory of gSoap used for receiving and processing
messages can be freed with soap_end.

Incoming messages can trigger the service methods to be called. This
happens inside the message processing functions that look like
<tt>[prefix defined in GSOAP_GENERATE cmake
macro]_serve_request</tt>. The function prototypes for the functions
are defined in <tt>[prefix defined in GSOAP_GENERATE cmake
macro]Stub.h</tt>. This file can be found in the build directory under
src/gen. In case of the airconditioner service these two function
prototypes are defined:

\code
SOAP_FMAC5 int SOAP_FMAC6
	   __acs1__GetStatus( struct soap*,
	   		      struct _acs1__EmptyMessage *acs1__GetStatus,
			      struct acs1__ACStateType *acs1__ACState);

SOAP_FMAC5 int SOAP_FMAC6
	   __acs1__SetTargetTemperature( struct soap*,
	   				 int acs1__TargetTemperature,
					 struct acs1__ACStateType *acs1__ACState);
\endcode

To implement the service logic theese two function must be
implemented. These function are similar to the operations defined in
acs.gsoap. The \c SOAP_FMAC5 and \c SOAP_FMAC6 macros can be ignored, but
the <tt>struct soap *</tt> parameter name must be added.

This is a simple implementation of the operation functionality:
\code
int temp = 23;

int __acs1__GetStatus(struct soap *soap,
    	              struct _acs1__EmptyMessage *acs1__GetStatus,
		      struct acs1__ACStateType *acs1__ACState)
{
  /* fill response message */
  acs1__ACState->CurrentTemp = temp;
  acs1__ACState->TargetTemp = temp;

  /* create response header */
  return dpws_header_gen_response (soap, NULL, wsa_header_get_ReplyTo (soap),
                                   "http://www.ws4d.org/axis2/tutorial/AirConditioner/GetStatusOut",
                                   wsa_header_get_MessageId (soap),
                                   sizeof (struct SOAP_ENV__Header));
}


int
__acs1__SetTargetTemperature (struct soap *soap,
                              int acs1__TargetTemperature,
                              struct acs1__ACStateType *acs1__ACState)
{
  /* process request message */
  temp = acs1__TargetTemperature;

  /* fill response message */
  acs1__ACState->CurrentTemp = temp;
  acs1__ACState->TargetTemp = temp;

  /* create response header */
  return dpws_header_gen_response (soap, NULL, wsa_header_get_ReplyTo (soap),
                                   "http://www.ws4d.org/axis2/tutorial/AirConditioner/SetTargetTemperatureOut",
                                   wsa_header_get_MessageId (soap),
                                   sizeof (struct SOAP_ENV__Header));
}
\endcode

There is a global temperature variable that holds the current
temperature. In our simple implementation the target temperature and
the current temperature are always the same as the airconditioner is
very fast when adjusting the temperature.

A operation skeleton function has a typical structure. First the input
message (request) is processed, the the output message (response) and
at last the response header is generated.

It is imported to know that the response message is sent after the
operation skeleton function. This means you should not use local
variables for the response message an the response header. Otherwise
you will get memory access problems as the local variables are not
valid when the message is sent. You should allocate memory for the
ouptut message and header wiht gSOAPs memory managment functions
(soap_malloc, soap_strdup, ...). A more detailed description how a
services logic should be implemented inside the skeleton functions can
be found in the gSOAP documentation.

Now the project is ready for a first build.

\subsection buildDevice Build the AirConditioner  device

In the Build directory you call cmake.

\verbatim
$ cd Build
$ make
[ 12%] Building C object src/CMakeFiles/acs_simple_device.dir/simple_airconditioner.o
Linking C executable ../bin/acs_simple_device
[100%] Built target acs_simple_device
\endverbatim

You will find the airconditioner device under Build/bin/acs_simple_device.

\subsection runDevice Running a device

To start the Airconditioner device we have to pass several arguments.
 - IP Address of the interface to operate on with the -i option
 - Device id in form "urn:uuid:[id as uuid]" with the -u option

\verbatim
$ cd Build/bin
$ ./acs_simple_device -i 192.168.1.100 -u urn:uuid:a2bb3689-62ff-4d13-8da8-82171e0916c3
Airconditioner: Set interface to "192.168.1.100"

Airconditioner: Set uuid to "urn:uuid:a2bb3689-62ff-4d13-8da8-82171e0916c3"

Airconditioner: ready to serve... (Ctrl-C for shut down)

Airconditioner: waiting for request

Airconditioner: processing request from 0.0.0.0:3702

Airconditioner: waiting for request

Airconditioner: processing request from 192.168.1.100:58051

Airconditioner: waiting for request

Airconditioner: processing request from 192.168.1.100:58052

Airconditioner: waiting for request

Airconditioner: shutting down...
\endverbatim

You can generate an uuid with the uuidgen tool. This should be available on all
unix or linux based systems. Under windows it is installed with Visual Studio
an can be used with the visual studio command prompt. If you don't pass an
uuid, the device will generate a random uuid. This is not the recommended
operation mode! A device should have a unique id that is persistent.

To stop the device press ctrl-c (press and hold ctrl and press c).

If the device was configured with debugging option (CMAKE_BUILD_TYPE =
Debug, the default mode) the device will create three log files with
information about the gsoap runtime (TEST.log), received messages (RECV.log)
and sent messages (SENT.log).

\section tutImplSimplClient Implementing a simple Client using the Airconditioner device

Now we implement a simple client that can use the GetStatus and
SetTargetTemperature operations of the airconditioner device.

\subsection tutUpdate2BuildSystem Update build system

We assume the existing project structure of the simple airconditioner example:
\verbatim
[Project Main Directory]
 |-- Build
 |-- CMakeLists.txt
 |-- buildversion
 |-- cmake-modules
 |   |-- FindDPWS-C.cmake
 |   |-- FindDPWS-D.cmake
 |   |-- FindDPWS.cmake
 |   `-- FindGSOAP.cmake
 `-- src
     |-- AirConditioner.wsdl
     |-- CMakeLists.txt
     |-- acs.gsoap
     |-- config.h.in
     |-- metadata.xml
     `-- simple_airconditioner.c
\endverbatim

Add the following section to the src/CMakeLists.txt to build the simple client:
\verbatim
###############################################################################
###############################################################################
##                                                                           ##
## Simple client                                                             ##
##                                                                           ##
###############################################################################
###############################################################################

################################################################################
# build simple client - for custom projects this must be modified
################################################################################

SET(simple_client_SRCS
	simple_client.c
	${GSOAP_STDSOAP2_SOURCE}
	${gen_DIR}/acs1ClientLib.c)

EXTEND_COMPILE_FLAGS(${simple_client_SRCS} FLAGS "-DDPWS_CLIENT")

ADD_EXECUTABLE(acs_simple_client ${simple_client_SRCS})

TARGET_LINK_LIBRARIES(acs_simple_client ${DPWS_LIBRARIES} ${DPWS-C_LIBRARIES})
\endverbatim
The acs_simple_client executable is created with the cmake macro ADD_EXECUTABLE.
All source debendencies are defined with the cmake variable
simple_client_SRCS.

In case of the simple client executable, following source files are
required:
 - simple_client.c: the simple client implementation
 - ${GSOAP_STDSOAP2_SOURCE}: the gSOAP runtime
 - ${gen_DIR}/acs1ClientLib.c: the client side code generated by soapcpp2 for the Airconditioner service

The EXTEND_COMPILE_FLAGS cmake macro is used to define the operation mode
"DPWS_CLIENT".

To use WS4D-gSOAP in client mode the libraries defined in ${DPWS_LIBRARIES}
${DPWS-C_LIBRARIES} must be linked into the binary with the
TARGET_LINK_LIBRARIES cmake macro.

Now we can create an minimal c code for an application and save it under
src/simple_client.c:
\verbatim
int main()
{
  return 0;
}
\endverbatim

The project tree should look like this:

\verbatim
[Project Main Directory]
 |-- Build
 |-- CMakeLists.txt
 |-- buildversion
 |-- cmake-modules
 |   |-- FindDPWS-C.cmake
 |   |-- FindDPWS-D.cmake
 |   |-- FindDPWS.cmake
 |   `-- FindGSOAP.cmake
 `-- src
     |-- AirConditioner.wsdl
     |-- CMakeLists.txt
     |-- acs.gsoap
     |-- simple_client.c
     |-- config.h.in
     |-- metadata.xml
     `-- simple_airconditioner.c
\endverbatim

To test our project environment we try to build the simple airconditioner
example.
\verbatim
$ cd Build
$ make
-- Using gnu patch: /usr/bin/patch
-- Found gSOAP in: /home/elmex/Dokumente/eclipse/gsoap-linux-2.7.10
-- Found DPWS in /home/elmex/Dokumente/eclipse/dpws-core/Install-Debug
-- Buildversion: 0.1

-- Build type not set, defaulting to DEBUG!
-- Choosing target is: device - none specified
-- Configuring done
-- Generating done
-- Build files have been written to: /home/elmex/test/Build
[  8%] Building C object src/CMakeFiles/acs_simple_client.dir/simple_client.o
[ 16%] Building C object src/CMakeFiles/acs_simple_client.dir/home/elmex/Dokumente/eclipse/gsoap-linux-2.7.10/gsoap/stdsoap2.o
[ 25%] Building C object src/CMakeFiles/acs_simple_client.dir/gen/acs1ClientLib.o
Linking C executable ../bin/acs_simple_client
[ 33%] Built target acs_simple_client
[ 41%] Generating gen/acs_wsdl.c, gen/acs_wsdl.h
[ 50%] Generating gen/acs1ServerLib.c, gen/acs1Server.c, gen/acs1ClientLib.c, gen/acs1Client.c, gen/acs1C.c, gen/acs1H.h, gen/acs1Stub.h, gen/acs1.nsmap

**  The gSOAP Stub and Skeleton Compiler for C and C++ 2.7.10
**  Copyright (C) 2000-2008, Robert van Engelen, Genivia Inc.
**  All Rights Reserved. This product is provided "as is", without any warranty.
**  The gSOAP compiler is released under one of the following three licenses:
**  GPL, the gSOAP public license, or the commercial license by Genivia Inc.

Using project directory path: /home/elmex/test/Build/src/gen/
Saving /home/elmex/test/Build/src/gen/acs1Stub.h
Saving /home/elmex/test/Build/src/gen/acs1H.h
Saving /home/elmex/test/Build/src/gen/acs1C.c
Saving /home/elmex/test/Build/src/gen/acs1Client.c
Saving /home/elmex/test/Build/src/gen/acs1ClientLib.c
Saving /home/elmex/test/Build/src/gen/acs1Server.c
Saving /home/elmex/test/Build/src/gen/acs1ServerLib.c
Using acs1 service name: ACServiceSoap12Binding
Using acs1 service style: document
Using acs1 service encoding: literal
Using acs1 service location:
Using acs1 schema namespace: http://www.ws4d.org/axis2/tutorial/AirConditioner
Saving /home/elmex/test/Build/src/gen/acs1.nsmap namespace mapping table

Compilation successful

[ 58%] Generating gen/acs_metadata.c, gen/acs_metadata.h
Scanning dependencies of target acs_simple_device
[ 66%] Building C object src/CMakeFiles/acs_simple_device.dir/simple_airconditioner.o
[ 75%] Building C object src/CMakeFiles/acs_simple_device.dir/home/elmex/Dokumente/eclipse/gsoap-linux-2.7.10/gsoap/stdsoap2.o
[ 83%] Building C object src/CMakeFiles/acs_simple_device.dir/gen/acs1ServerLib.o
[ 91%] Building C object src/CMakeFiles/acs_simple_device.dir/gen/acs_metadata.o
[100%] Building C object src/CMakeFiles/acs_simple_device.dir/gen/acs_wsdl.o
Linking C executable ../bin/acs_simple_device
[100%] Built target acs_simple_device
\endverbatim

This will work but the simple_client won't do something useful. First we
have to implement the client logic that uses the GetSatus operation.

\subsection tutImplSimplClientGS Implementing the SimpleClient using the GetSatus operation

The next step is to implement a client using the GetStatus opertion of
the AirConditioner service on the AirConditioner device. Therefor the following
code must be added to src/simple_client.c:

First we have to specify the include files:

\code
#include "acs1.nsmap"
#include "dpws_client.h"

#include "ws4d_eprllist.h"
\endcode

 - acs1.nsmap is generated by soapcpp2 and includes the namespace
   table of the service and the prototypes of all generated functions
   und structures. You can only include one nsmap file in every C
   file. If you want implement more than one service in a device you
   have to implement them in seperate C files.

 - dpws_device.h is the include file for funcitons and structures
   offered by the dpws device library.

 - ws4d_eprllist.h is an implementation of the abstract endpoint reference list
   interface, that is used in the WS4D-gSOAP toolkit to pass lists of endpoint
   references.

We declare the soap and dpws handle globally.

\code
struct soap client;
struct dpws_s dpws;
\endcode

Now we can start the main function. The first part of the main
function is the declaration of variables.

\code
int
main (int argc, char **argv)
{
  ws4d_alloc_list alist;

  struct acs1__ACStateType ACState;

  struct ws4d_epr device, *service = NULL;
  struct ws4d_abs_eprlist services;
  ws4d_qnamelist service_type_list;

  char *deviceaddr = NULL, *interface = NULL, *XAddrs = NULL;
\endcode

 - alist: allocation list to manage memory allocations nedded in the simple client

 - ACState: structure for storing the results of an operation call.

 - device, service: end point references for the device und the service to use

 - services: endpoint reference list to be uses for service discovery later on

 - service_type_list: a qname list used for finding the wanted service on the device

 - deviceaddr, interface, XAddrs: miscellaneous variables

The next part is code for parsing the command line. We expect one
parameter -h to specify the host device, one parameter with the
logical device adress (uuid) of the device we want to use.

\code
  /* parsing command line options */
  while (argc > 1)
    {
      if (argv[1][0] == '-')
        {
          char *option = &argv[1][1];
          switch (option[0])
            {
            case 'i': /* set interface with option -i */
              if (strlen (option) > 2)
                {
                  ++option;
                  interface = option;
                }
              else
                {
                  --argc;
                  ++argv;
                  interface = argv[1];
                }
#ifdef DEBUG
              printf ("\nsimple_client: Set interface to \"%s\"\n", interface);
#endif
              break;
            case 'd': /* set device address with option -d */
              if (strlen (option) > 2)
                {
                  ++option;
                  deviceaddr = option;
                }
              else
                {
                  --argc;
                  ++argv;
                  deviceaddr = argv[1];
                }
#ifdef DEBUG
              printf ("\nsimple_client: Set device address to \"%s\"\n", deviceaddr);
#endif
              break;
            default:
              fprintf (stderr, "\nsimple_client: Bad option %s\n", argv[1]);
              printf ("\n%s -i [interface address] -d [device address]\n", argv[0]);
              exit(1);
            }
        }
      --argc;
      ++argv;
    }

  if (interface == NULL)
    {
      fprintf (stderr, "\nsimple_client: No interface address was specified!\n");
      exit (1);
    }

  if (deviceaddr == NULL)
    {
      fprintf (stderr, "\nsimple_client: No device address was specified!\n");
      exit (1);
    }
\endcode

After parsing the command line, the allocation list is initialized,

\code
  WS4D_ALLOCLIST_INIT (&alist);
\endcode

Now the soap handle can be initialized.

\code
  /* initialize soap handle */
  soap_init (&client);
#ifdef DEBUG
  soap_omode (&client, SOAP_XML_INDENT);
#endif
\endcode

After initialization of the soap handle, the dpws handle must be
initialized.

\code
  /* initialize WS4D-gSOAP */
  if (dpws_init (&dpws, interface) != SOAP_OK)
    {
      fprintf (stderr, "\nsimple_client: could not initialize dpws handle\n");
      dpws_done (&dpws);
      exit (1);
    }
\endcode

In the WS4D-gSOAP API we use end point references (EPR) (in this case
of type struct wsa_eprlist_elem) to adress endpoints. So to resolve
the logical adress of a device passed as a command line parameter, we
have to allocate an epr structure and assignt the logical adress.

\code
  /* prepare device epr to resolve */
  ws4d_epr_init (&device);
  ws4d_epr_set_Addrs (&device, deviceaddr);
\endcode

Then we can pass this epr to the dpws_resolve_addr() function. The
function resolves a logical device address (uuid form) into a http address.

\code
  /* resolve address */
  XAddrs = (char *) dpws_resolve_addr(&dpws, &device, NULL, 10000);
  if (XAddrs != NULL)
    {
#ifdef DEBUG
      printf("\nsimple_client: device %s found at addr %s\n",
             ws4d_epr_get_Addrs(&device), XAddrs);
#endif
    }
  else
    {
      fprintf(stderr, "\nsimple_client: device %s cannot be found\n",
              ws4d_epr_get_Addrs(&device));
      exit(1);
    }
\endcode

After resolving the logacal adress we have to search for the adress of
the service on the device we want to use. The services can be filterd
by service type oder by service id. In this case we initialize a
service type list with the service type of the AirConditioner service
AirConditionerInterface.

\code
  /* prepare service type list */
  ws4d_qnamelist_init (&service_type_list);
  ws4d_qnamelist_addstring
    ("\"http://www.ws4d.org/axis2/tutorial/AirConditioner\":AirConditionerInterface",
     &service_type_list, &alist);
\endcode

Then we pass the service type list and the resolved device epr to the
dpws_find_services() function to get the epr of the service we want to
use.

\code
  /* look up service with matching service types on device */
  ws4d_eprlist_init(&services, ws4d_eprllist_init, NULL);
  if (dpws_find_services(&dpws, &device, &service_type_list, 10000, &services)
      == SOAP_OK)
    {
      /* use first service */
      service = ws4d_eprlist_get_first(&services);
#ifdef DEBUG
      printf("\nsimple_client: device offers AirConditionerService at %s\n",
             ws4d_epr_get_Addrs(service));
#endif
    }
  else
    {
      fprintf(stderr,
              "\nsimple_client: AirConditionerService not found on %s\n",
              ws4d_epr_get_Addrs(&device));
      exit(1);
    }
\endcode

If we have the service epr and the thus its address, we can set up the
soap handle to call the GetStatus operation. First we have to set up
namespaces of the soap handle. Then the soap header of the request
message must be generated with dpws_header_gen_request(). To generate
the header we have to pass the soap handle, we want to use leater, the
service address with ws4d_epr_get_Addrs() and the action of
the input message as specified in the WSDL.

\code
  /* prepare soap handel to use service */
  soap_set_namespaces(&client, acs1_namespaces);
  dpws_header_gen_request(&client, NULL, ws4d_epr_get_Addrs(service),
      "http://www.ws4d.org/axis2/tutorial/AirConditioner/GetStatusIn", NULL,
      NULL, sizeof(struct SOAP_ENV__Header));
\endcode

Now we can call the service with the stub function for the GetSatus
operation generated by soapcpp2. The function has the following
prototyp, as you can see in acs1Stub.h in [Build directorry]/src/gen/.

\code
SOAP_FMAC5 int SOAP_FMAC6
     soap_call___acs1__SetTargetTemperature(struct soap *soap,
              const char *soap_endpoint,
              const char *soap_action,
              int acs1__TargetTemperature,
              struct acs1__ACStateType *acs1__ACState);
\endcode

To call this function correctly we have to pass the client soap
handle, the soap_endpoint (the service address in this case) and the
result structure ACState. If the function returns SOAP_OK the
operation call was sucessfull. The result values can then be found in
the ACState structure.

\code
  /* call GetStatus operation */
  if (soap_call___acs1__GetStatus(&client, ws4d_epr_get_Addrs (service),
                                  NULL, NULL, &ACState) == SOAP_OK)
    {
#ifdef DEBUG
      printf("\nsimple_client: got status from %s\n",
             ws4d_epr_get_Addrs(service));
#endif

      printf ("\nCurrentTemp: %d\nTargetTemp: %d\n", ACState.CurrentTemp, ACState.TargetTemp);
    }
  else
    {
      fprintf(stderr, "\nsimple_client: error calling GetStatus on %s\n",
              ws4d_epr_get_Addrs(service));
    }
\endcode

After the operation call we have to clean up the allocated memory to
shutdown the application. First we have to call soap_end() and
soap_done() with the soap handle. Then we have to shutdown the stack
by calling dpws_done with the dpws handle as parameter. After freeing
the device epr we free the remaining allocations in the allocation
list by calling soap_free_list().

\code
  /* clean up */
  soap_end(&client);
  soap_done(&client);
  dpws_done(&dpws);

  ws4d_eprlist_done(&services);
  ws4d_epr_reset(&device);

  ws4d_alloclist_done(&alist);

  exit (0);
}
\endcode

\subsection compSimplClient Build the simple client

In the Build directory you call cmake.

\verbatim
$ cd Build
$ make
Scanning dependencies of target acs_simple_client
[  8%] Building C object src/CMakeFiles/acs_simple_client.dir/simple_client.o
Linking C executable ../bin/acs_simple_client
[ 33%] Built target acs_simple_client
[100%] Built target acs_simple_device
\endverbatim

\subsection runSimplClient Running a client implementation

To start the simple client we have to pass several arguments.

 - IP Address of the interface to operate on with the -i option
 - Device address in form "urn:uuid:[id as uuid]" orf "http://" with the -d option

\verbatim
$ cd Build/bin
$ ./acs_simple_client -i 192.168.1.100 -d urn:uuid:a2bb3689-62ff-4d13-8da8-82171e0916c3

simple_client: Set interface to "192.168.1.100"

simple_client: Set device address to "urn:uuid:a2bb3689-62ff-4d13-8da8-82171e0916c3"

simple_client: device urn:uuid:a2bb3689-62ff-4d13-8da8-82171e0916c3 found at addr http://192.168.1.100:36032

simple_client: device offers AirConditionerService at http://192.168.1.100:36032/

simple_client: got status from http://192.168.1.100:36032/

CurrentTemp: 23
TargetTemp: 23
\endverbatim

If the client was configured with debugging option (CMAKE_BUILD_TYPE = Debug,
the default mode) the client will create three log files with information about
the gsoap runtime (TEST.log), received messages (RECV.log) and sent messages
(SENT.log).

\section tutImplAdvDevice Implementing an advanced AirConditioner device with Eventing

The WSDL of the AirConditioner service contains a third operation
called TemperatureEvent that ist not implemented in the device
before. This message has a special message exchange pattern. There is
only a TemperatureEventMessageOut that is sent by the device to the
client. To allow this message exchange pattern, that is used for
events and notifications, a special mechanism is needed. WS-Eventing,
that is used by DPWS defines a subscription mechanism for events and
notifications.

Implementing Events with WS4D-gSOAP is a litte bit mir
complicated. Several steps are needed:

 - Activate event source and subscription management (subscription
   manager)
 - Implement an event triggering function

As gSOAPs code generator soapcpp2 is designed for the typical request
response and oneway message exchange patterns, we have to generate
separate stub and skeleton for the event operations. This is done on
the bases of an inverted WSDL. There is a tool based on XSLT to invert
a WSDL included in the toolkit. This tool simply reverses the order of
input and output tags in operations. So we generate again a gSOAP file
based on this inverted WSDL, generate stub and skeleton code but
include the client sind on the device and the server side on the
client this time.

So wo have to to the following steps:

 - invert WSDL
 - generate inverted gSOAP file acs_inv.gsoap
 - adapt acs_inv.gsoap
 - generate stub and skeleton code
 - activate event source and subscription management
 - Implement an event triggering function with the generated stub code of the inverted service

The WSDL can be inverted with the following command line:

\verbatim
$ cd src
$ xsltproc -o AirConditioner.wsdl_inv [path to WS4D-gSOAP installation]/share/ws4d-gSOAP/invert.xslt AirConditioner.wsdl
\endverbatim

Now we generate the inverted gSOAP file acs_inv.gsoap

\verbatim
$ cd src
$ wsdl2h -c -n acsinv AirConditioner.wsdl_inv -o acs_inv.gsoap
\endverbatim

Now you should open acs_inv.gsoap in an editor. Before you apply the
modifications as described in \ref tutInterface you should remove all
operations that are not ment to be events. In this case you must
remove all parts that belong to the GetStatus and the
SetTargetTemperature operations.

\subsection tutUpdate3BuildSystem Update build system

We assume the existing project structure of the simple client example with the
new files AirConditioner.wsdl_inv and acs_inv.gsoap:

\verbatim
[Project Main Directory]
 |-- Build
 |-- CMakeLists.txt
 |-- buildversion
 |-- cmake-modules
 |   |-- FindDPWS-C.cmake
 |   |-- FindDPWS-D.cmake
 |   |-- FindDPWS.cmake
 |   `-- FindGSOAP.cmake
 `-- src
     |-- AirConditioner.wsdl
     |-- AirConditioner.wsdl_inv
     |-- CMakeLists.txt
     |-- acs.gsoap
     |-- acs_inv.gsoap
     |-- simple_client.c
     |-- config.h.in
     |-- metadata.xml
     `-- simple_airconditioner.c
\endverbatim

Add the following section to the src/CMakeLists.txt to build the
aircondtitioner device:
\verbatim
###############################################################################
###############################################################################
##                                                                           ##
## air conditioner device with eventing                                      ##
##                                                                           ##
###############################################################################
###############################################################################

# generate code and C data binding for events of service
GSOAP_GENERATE(acs_inv.gsoap acs_inv1 ${gen_DIR}) # event service

SET (advanced_arcondtitioner_SRCS
	advanced_airconditioner.c
	event_worker.c
	${GSOAP_STDSOAP2_SOURCE}
	${gen_DIR}/acs1ServerLib.c
	${gen_DIR}/acs_inv1ClientLib.c
	${gen_DIR}/acs_metadata.c
	${gen_DIR}/acs_wsdl.c)

EXTEND_COMPILE_FLAGS(${advanced_arcondtitioner_SRCS}
	FLAGS "-DDPWS_DEVICE -DWITH_MUTEXES")

# compile all files in simple_arcondtitioner_SRCS and link them into
# the acs_simple_device executable
ADD_EXECUTABLE(acs_advanced_device ${advanced_arcondtitioner_SRCS})

# link the device specific dpws libraries into the airconditioner executable
TARGET_LINK_LIBRARIES(acs_advanced_device
	${DPWS_LIBRARIES} ${DPWS-DMT_LIBRARIES} ${CMAKE_THREAD_LIBS_INIT})
\endverbatim

The airconditioner device executable is created with the cmake macro
ADD_EXECUTABLE. All source debendencies are defined with the cmake variable
advanced_arcondtitioner_SRCS.

In case of the airconditioner device executable, following source files are
required:
 - advanced_airconditioner.c: the airconditioner service implementation
 - event_worker.c: a airconditionder state machine and event source
 - ${GSOAP_STDSOAP2_SOURCE}: the gSOAP runtime
 - ${gen_DIR}/acs1ServerLib.c: the server side code generated by soapcpp2
 - ${gen_DIR}/acs_inv1ClientLib.c: the client side code for the event source generated by soapcpp2
 - ${gen_DIR}/acs_metadata.c:
 - ${gen_DIR}/acs_wsdl.c:

The EXTEND_COMPILE_FLAGS cmake macro is used to define the operation mode
"DPWS_DEVICE". The airconditioner device uses threads for simultaneously
running tasks. Thus the airconditioner device uses the multithreading mode of
the WS4D-gSOAP toolkit activeted with "WITH_MUTEXES".

To use WS4D-gSOAP in device mode with multi threading the libraries defined
in ${DPWS_LIBRARIES} ${DPWS-DMT_LIBRARIES} and the pthread libraries must be
linked into the binary with the TARGET_LINK_LIBRARIES cmake macro.

Now we can create an emtpty eventworker.c and minimal c code for an application
and save it under src/advanced_airconditioner.c:
\verbatim
int main()
{
  return 0;
}
\endverbatim

The project tree should look like this:

\verbatim
[Project Main Directory]
 |-- Build
 |-- CMakeLists.txt
 |-- buildversion
 |-- cmake-modules
 |   |-- FindDPWS-C.cmake
 |   |-- FindDPWS-D.cmake
 |   |-- FindDPWS.cmake
 |   `-- FindGSOAP.cmake
 `-- src
     |-- AirConditioner.wsdl
     |-- AirConditioner.wsdl_inv
     |-- CMakeLists.txt
     |-- acs.gsoap
     |-- acs_advanced_device.c
     |-- acs_inv.gsoap
     |-- simple_client.c
     |-- config.h.in
     |-- event_worker.c
     |-- metadata.xml
     `-- simple_airconditioner.c
\endverbatim

To test our project environment we try to build the project.
\verbatim
$ cd Build
$ make
-- Using gnu patch: /usr/bin/patch
-- Found gSOAP in: /home/elmex/Dokumente/eclipse/gsoap-linux-2.7.10
-- Found DPWS in /home/elmex/Dokumente/eclipse/dpws-core/Install-Debug
-- Buildversion: 0.1

-- Build type not set, defaulting to DEBUG!
-- Choosing target is: device - none specified
-- Configuring done
-- Generating done
-- Build files have been written to: /home/elmex/test/Build
[  4%] Generating gen/acs_wsdl.c, gen/acs_wsdl.h
[  8%] Generating gen/acs1ServerLib.c, gen/acs1Server.c, gen/acs1ClientLib.c, gen/acs1Client.c, gen/acs1C.c, gen/acs1H.h, gen/acs1Stub.h, gen/acs1.nsmap

**  The gSOAP Stub and Skeleton Compiler for C and C++ 2.7.10
**  Copyright (C) 2000-2008, Robert van Engelen, Genivia Inc.
**  All Rights Reserved. This product is provided "as is", without any warranty.
**  The gSOAP compiler is released under one of the following three licenses:
**  GPL, the gSOAP public license, or the commercial license by Genivia Inc.

Using project directory path: /home/elmex/test/Build/src/gen/
Saving /home/elmex/test/Build/src/gen/acs1Stub.h
Saving /home/elmex/test/Build/src/gen/acs1H.h
Saving /home/elmex/test/Build/src/gen/acs1C.c
Saving /home/elmex/test/Build/src/gen/acs1Client.c
Saving /home/elmex/test/Build/src/gen/acs1ClientLib.c
Saving /home/elmex/test/Build/src/gen/acs1Server.c
Saving /home/elmex/test/Build/src/gen/acs1ServerLib.c
Using acs1 service name: ACServiceSoap12Binding
Using acs1 service style: document
Using acs1 service encoding: literal
Using acs1 service location:
Using acs1 schema namespace: http://www.ws4d.org/axis2/tutorial/AirConditioner
Saving /home/elmex/test/Build/src/gen/acs1.nsmap namespace mapping table

Compilation successful

[ 13%] Generating gen/acs_inv1ServerLib.c, gen/acs_inv1Server.c, gen/acs_inv1ClientLib.c, gen/acs_inv1Client.c, gen/acs_inv1C.c, gen/acs_inv1H.h, gen/acs_inv1Stub.h, gen/acs_inv1.nsmap

**  The gSOAP Stub and Skeleton Compiler for C and C++ 2.7.10
**  Copyright (C) 2000-2008, Robert van Engelen, Genivia Inc.
**  All Rights Reserved. This product is provided "as is", without any warranty.
**  The gSOAP compiler is released under one of the following three licenses:
**  GPL, the gSOAP public license, or the commercial license by Genivia Inc.


**WARNING**: option -1 or -2 overrides SOAP-ENV namespace (detected at line 44 in /home/elmex/test/src/acs_inv.gsoap)


**WARNING**: option -1 or -2 overrides SOAP-ENC namespace (detected at line 45 in /home/elmex/test/src/acs_inv.gsoap)

Using project directory path: /home/elmex/test/Build/src/gen/
Saving /home/elmex/test/Build/src/gen/acs_inv1Stub.h
Saving /home/elmex/test/Build/src/gen/acs_inv1H.h
Saving /home/elmex/test/Build/src/gen/acs_inv1C.c
Saving /home/elmex/test/Build/src/gen/acs_inv1Client.c
Saving /home/elmex/test/Build/src/gen/acs_inv1ClientLib.c
Saving /home/elmex/test/Build/src/gen/acs_inv1Server.c
Saving /home/elmex/test/Build/src/gen/acs_inv1ServerLib.c
Using acsinv1 service name: ACServiceSoap12Binding
Using acsinv1 service style: document
Using acsinv1 service encoding: literal
Using acsinv1 service location:
Using acsinv1 schema namespace: http://www.ws4d.org/axis2/tutorial/AirConditioner
Saving /home/elmex/test/Build/src/gen/acs_inv1.nsmap namespace mapping table

Compilation successful (2 warnings)

[ 17%] Generating gen/acs_metadata.c, gen/acs_metadata.h
Scanning dependencies of target acs_advanced_device
[ 21%] Building C object src/CMakeFiles/acs_advanced_device.dir/advanced_airconditioner.o
[ 26%] Building C object src/CMakeFiles/acs_advanced_device.dir/event_worker.o
[ 30%] Building C object src/CMakeFiles/acs_advanced_device.dir/home/elmex/Dokumente/eclipse/gsoap-linux-2.7.10/gsoap/stdsoap2.o
[ 34%] Building C object src/CMakeFiles/acs_advanced_device.dir/gen/acs1ServerLib.o
[ 39%] Building C object src/CMakeFiles/acs_advanced_device.dir/gen/acs_inv1ClientLib.o
[ 43%] Building C object src/CMakeFiles/acs_advanced_device.dir/gen/acs_metadata.o
[ 47%] Building C object src/CMakeFiles/acs_advanced_device.dir/gen/acs_wsdl.o
Linking C executable ../bin/acs_advanced_device
CMakeFiles/acs_advanced_device.dir/gen/acs1ServerLib.o: In function `soap_serve___acs1__GetStatus':
/home/elmex/test/Build/src/gen/acs1Server.c:99: undefined reference to `__acs1__GetStatus'
CMakeFiles/acs_advanced_device.dir/gen/acs1ServerLib.o: In function `soap_serve___acs1__SetTargetTemperature':
/home/elmex/test/Build/src/gen/acs1Server.c:140: undefined reference to `__acs1__SetTargetTemperature'
collect2: ld gab 1 als Ende-Status zurück
make[2]: *** [bin/acs_advanced_device] Fehler 1
make[1]: *** [src/CMakeFiles/acs_advanced_device.dir/all] Fehler 2
make: *** [all] Fehler 2
\endverbatim

This won't work, because the functions __acs1__GetStatus and
__acs1__SetTargetTemperature must be implemented.

\subsection tutImplEventWorker Implementing the AirConditioner device with eventing

At the moment it is not possible to implement several services for
dpws in one c file because auf namespace conflicts. So we implement
the eventing mechanism in a separate c file called
event_worker.c. Besides the event delivery we also implement a state
machine with the states of the AirConditioner service in this file.

First we have to specify the include files:

\code
#include "acs_inv1.nsmap"
#include "dpws_device.h"
#ifndef WIN32
#include <pthread.h>
#endif
\endcode

 - acs_inv1.nsmap is generated by soapcpp2 and includes the namespace
table of the stubs for the event source.

 - dpws_device.h is the include file for funcitons and structures
offered by the dpws device library.

 - pthread.h for multithreeading support

The following code is not specific for DPWS or the usage of the
WS4D-gSOAP toolkit, but an example how to implement a state machine
for the airconditioner. You can skip this section if you want to
implement your own state machine.

First we need some global variables, for keeping a dpws handle
reference, the airconditioner state and handles for multi threading.

\code
/* reference to device handle */
struct dpws_s *_device = NULL;

/* Supported states of the air conditioner. */
enum ac_states { OFF, IDLE, COOLING };
int currentState = OFF;         /* Initial state is turned off. */
int currentTemp = 24;           /* Initial temperature in degrees celsius. */
int targetTemp = 24;            /* Initial target temperature in degrees celsius. */
int shutdownFlag = 0;           /* Flag indicates systemshutdown. */

/* handle for multithreading */
#ifdef WIN32
DWORD workerid;
HANDLE worker;
#else
pthread_t worker;
#endif
\endcode

Then we need an initialization and a shutdown function.

\code
void *event_worker_loop ();

int
event_worker_init (struct dpws_s *device)
{
  if (_device)
    {
      return SOAP_ERR;
    }
  else
    {
      if (!device)
	{
	  return SOAP_ERR;
	}
      _device = device;
    }

#ifdef WIN32
  worker = CreateThread (NULL, 0, (DWORD WINAPI) event_worker_loop, NULL, 0, &workerid);
  if (worker != NULL)
#else
  if (pthread_create (&worker, NULL, event_worker_loop, NULL) == 0)
#endif
    {
      return SOAP_OK;
    }
  else
    {
      return SOAP_ERR;
    }
}
\endcode

This function initializes the device handle reference with the passed
device handle and creates a thread for the state machine that is
implemented in the event_worker_loop function.

\code
int
event_worker_shutdown ()
{
  shutdownFlag = 1;
#ifdef WIN32
  WaitForSingleObject(worker, INFINITE);
#else
  pthread_join (worker, NULL);
#endif
}
\endcode

The event_worker_shutdown function sets the shutdownFlag which is
monitored in the event_worker_loop function. Then it waits for the
event_worker_loop function to finish.

\code
int
event_worker_get_current ()
{
  return currentTemp;
}
\endcode

This function returns the current temperature of the state machine.

\code
int
event_worker_set_target (int target)
{
  targetTemp = target;
  if (currentState == OFF)
    {
      currentState = IDLE;
    }
}


int
event_worker_get_target ()
{
  return targetTemp;
}
\endcode

This functions set and return the target temperature of the state
machine.

\code
void deliver_event (int CurrentTemp, int TargetTemp);

void *
event_worker_loop ()
{
  /* Wait for initial start. */
  while (OFF == currentState && !shutdownFlag)
    SLEEP (1);

  printf ("Airconditioner: Entering working loop...\n");
  while (!shutdownFlag)
    {
      if (targetTemp < currentTemp)
        {
          printf
            ("Airconditioner: Current Temperature %d; Switching to state COOLING.\n",
             currentTemp);
          currentState = COOLING;

          while (targetTemp <= currentTemp && !shutdownFlag)
            {
              currentTemp--;
              SLEEP (5);
            }
        }
      else
        {
          printf
            ("Airconditioner: Reached target temperature: %d; Switching to state IDLE.\n",
             targetTemp);
          currentState = IDLE;

          deliver_event (currentTemp, targetTemp);

          SLEEP (5);
          currentTemp += 2;
        }
    }
  printf ("Airconditioner: Leaving working loop...\n");
}
\endcode

The function event_worker_loop() implements the state machine of the
AirConditioner service.

The functionality of the event_worker module is exported with the
following header file. Later on the event_worker module must be
integrated into the airconditioner device.

\code
#ifndef EVENT_WORKER_H_
#define EVENT_WORKER_H_

int
event_worker_init (struct dpws_s *device);

int
event_worker_shutdown ();

int event_worker_get_current ();

int event_worker_set_target (int target);

int event_worker_get_target ();

#endif /*EVENT_WORKER_H_*/
\endcode

At the moment many parts of the event delivery have to be implemented
by the device developer. In principle an event delivery of a specific
event must be triggerd by the device implementation.

\code
void
deliver_event (int CurrentTemp, int TargetTemp)
{
  struct soap soap;
  struct ws4d_subscription *subs, *next;
  struct acsinv1__ACStateType event;

  event.CurrentTemp = CurrentTemp;
  event.TargetTemp = TargetTemp;

  soap_init (&soap);
  soap_set_namespaces (&soap, acs_inv1_namespaces);

  dpws_for_each_subs (subs, next, _device,
                      "http://www.ws4d.org/axis2/tutorial/AirConditioner/TemperatureEventOut")
  {
    struct __acsinv1__TemperatureEvent response;
    char *deliverto = dpws_subsm_get_deliveryPush_address (_device, subs);

    if (!deliverto)
      continue;

    dpws_header_gen_oneway (&soap, NULL, deliverto,
                            "http://www.ws4d.org/axis2/tutorial/AirConditioner/TemperatureEventOut",
                            NULL, sizeof (struct SOAP_ENV__Header));

    printf ("Sending Event to %s\n", deliverto);

    if (soap_send___acsinv1__TemperatureEvent
        (&soap, deliverto, NULL, &event))
      {
        soap_print_fault (&soap, stderr);
      }
    else
      {
        soap_recv___acsinv1__TemperatureEvent (&soap, &response);
      }

    soap_end (&soap);
  }

  soap_done (&soap);
}
\endcode

An event delivery function must iterate over the subscriptions known
by the subscription manager and filter out those that are
subscriptions for the event to be delivered. There are two functions
dpws_subsm_get_first_by_action and dpws_subsm_get_next_by_action to
iterate over all known subscriptions and filter them by the specified
action filter.

Then for each matching function the delivery address must be acquierd
with the function dpws_subsm_get_deliveryPush_address().

The event message itself is delivered like a typical message send by a
client. First we have to allocate and initialize a soap handle (this
is done outsinde of the subscription filter loop), generate a dpws
header. Depending on the message exchange pattern used by the
operation used for event delivery, soapcpp has created a
soap_call_[...] function (for solicit response) or a pair of
soap_send_[...] and soap_recv_[...] function (for notification). In
the letter case the recv function must be used to recv the http
response, if omitted the device is not dpws compliant and may cause
problems on some clients.

After sending the event, all memory allocated for the soap handle must
be freed with soap_end() and soap_done().

The differences of simple_airconditioner.c and advanced_airconditioner.c are
minimal. So the best was to create advanced_airconditioner.c is to copy
simple_airconditioner.c to advanced_airconditioner.c and integrate the
following changes.

First we have to add the include file of event worker:
\code
#include "event_worker.h"
\endcode

Then we have to add the event_worker_shoutdown() function to
service_exit() function to properly shut the event_worker thread down.

\code
service_exit ()
{
  printf ("\nAirconditioner: shutting down...\n");

  event_worker_shutdown();

  dpws_deactivate_hosting_service (&device);
  soap_done (&service);
  dpws_done (&device);

  exit (0);
}
\endcode

The next step is important, as if we omit htis, the device won't
accept subscriptions. To accept subscriptions we have to activate the
event source on the AirConditioner service. This can be done with the
dpws_activate_eventsource function, where we have to passe the device
handle and the soap handel where the AirConditioner service is bound
to. This should be done after the service was set up but before we
start the message processing loop.

\code
[...]

  /* activate eventing. */
  if (dpws_activate_eventsource (&device, &service))
    {
      printf ("\nAirconditioner: Can't activate eventing\n");
      dpws_done (&device);
      exit (0);
    }

  /* install signal handler for SIGINT or Ctrl-C */
#ifdef WIN32
  signal (SIGINT, service_exit);
#else
  memset (&sa, 0, sizeof (sa));
  sa.sa_handler = service_exit;
  sigaction (SIGINT, &sa, NULL);
#endif
  if (event_worker_init(&device))
  {
      printf ("\nAirconditioner: Can't init event worker\n");
      dpws_done (&device);
      exit (0);
  }

[...]
\endcode

After activating the event source, we have to initialize the event
worker with the function event_worker_init implemented in
event_worker.c

To automatically expire subscriptions the function dpws_check_subscriptions()
must be integrated into the main loop.

\code
#ifdef DEBUG
  printf ("\nAirconditioner: ready to serve... (Ctrl-C for shut down)\n");
#endif

  for (;;)
    {
      struct soap *handle = NULL, *soap_set[] = SOAP_HANDLE_SET (&service);
      int (*serve_requests[]) (struct soap * soap) =
        SOAP_SERVE_SET (acs1_serve_request);

#ifdef DEBUG
      printf ("\nAirconditioner: waiting for request\n");
#endif

      /* waiting for new messages */
      handle = dpws_maccept (&device, 100000, 1, soap_set);

      if (handle)
        {

#ifdef DEBUG
          printf ("\nAirconditioner: processing request from %s:%d\n",
                  inet_ntoa (handle->peer.sin_addr),
                  ntohs (handle->peer.sin_port));
#endif

          /* dispatch messages */
          if (dpws_mserve (handle, 1, serve_requests))
            {
              soap_print_fault (handle, stderr);
            }

          /* clean up soaps internaly allocated memory */
          soap_end (handle);
        }

      dpws_check_subscriptions (&device);

    }

  return -1;
\endcode

At least we have to integrate the function to get and set target and
current temperature. The operation skeletons of GetStatus and
SetTemperature then looks like.

\code
int __acs1__GetStatus(struct soap *soap,
                      void *_,
                      struct acs1__ACStateType *acs1__ACState)
{
  /* fill response message */
  acs1__ACState->CurrentTemp = event_worker_get_current();
  acs1__ACState->TargetTemp = event_worker_get_target();

  /* create response header */
  return dpws_header_gen_response (soap, NULL, wsa_header_get_ReplyTo (soap),
                                   "http://www.ws4d.org/axis2/tutorial/AirConditioner/GetStatusOut",
                                   wsa_header_get_MessageId (soap),
                                   sizeof (struct SOAP_ENV__Header));
}


int
__acs1__SetTargetTemperature (struct soap *soap,
                              int acs1__TargetTemperature,
                              struct acs1__ACStateType *acs1__ACState)
{
  /* process request message */
  event_worker_set_target ( acs1__TargetTemperature);

  /* fill response message */
  acs1__ACState->CurrentTemp = event_worker_get_current();
  acs1__ACState->TargetTemp = event_worker_get_target();

  /* create response header */
  return dpws_header_gen_response (soap, NULL, wsa_header_get_ReplyTo (soap),
                                   "http://www.ws4d.org/axis2/tutorial/AirConditioner/SetTargetTemperatureOut",
                                   wsa_header_get_MessageId (soap),
                                   sizeof (struct SOAP_ENV__Header));
}
\endcode

\subsection buildAdvDevice Build the advanced airconditioner device

In the Build directory you call make.

\verbatim
$ cd Build
$ make
[  4%] Building C object src/CMakeFiles/acs_advanced_device.dir/advanced_airconditioner.o
[  8%] Building C object src/CMakeFiles/acs_advanced_device.dir/event_worker.o
Linking C executable ../bin/acs_advanced_device
[ 47%] Built target acs_advanced_device
[ 52%] Building C object src/CMakeFiles/acs_simple_client.dir/simple_client.o
[ 56%] Building C object src/CMakeFiles/acs_simple_client.dir/home/elmex/Dokumente/eclipse/gsoap-linux-2.7.10/gsoap/stdsoap2.o
[ 60%] Building C object src/CMakeFiles/acs_simple_client.dir/gen/acs1ClientLib.o
Linking C executable ../bin/acs_simple_client
[ 65%] Built target acs_simple_client
[ 69%] Building C object src/CMakeFiles/acs_simple_device.dir/simple_airconditioner.o
[ 73%] Building C object src/CMakeFiles/acs_simple_device.dir/home/elmex/Dokumente/eclipse/gsoap-linux-2.7.10/gsoap/stdsoap2.o
[ 78%] Building C object src/CMakeFiles/acs_simple_device.dir/gen/acs1ServerLib.o
[ 82%] Building C object src/CMakeFiles/acs_simple_device.dir/gen/acs_metadata.o
[ 86%] Building C object src/CMakeFiles/acs_simple_device.dir/gen/acs_wsdl.o
Linking C executable ../bin/acs_simple_device
[100%] Built target acs_simple_device
\endverbatim

\section tutImplAdvClient Implementing an advanced client with eventing

To be done :-)

*/


/**
 * gSOAP DPWS Plugin API
 *
 * @addtogroup DPWSAPI DPWS-API
 *
 *
 * The gSOAP DPWS Plugin implements the devices and the client side of the
 * Devices Profile for Web Services. The compile time swithces DPWS_DEVICE and
 * DPWS_CLIENT can be used to choose between the device and the client
 * implementation. The DPWS_PEER switch is used for endpoints acting as devic
 * as well as client.
 *
 * @{
 */

 /**
 * @addtogroup APIDevice Device side API
 * @ingroup DPWSAPI
 *
 *
 * This is the device side implementation of the gSOAP DPWS Plugin activated
 * with the DPWS_DEVICE compile time switch.
 *
 * @{
 */

/** @} */

/**
 * @addtogroup DPWSAPIClient Client side API
 * @ingroup DPWSAPI
 *
 *
 * This is the client side implementation of the gSOAP DPWS Plugin activated
 * with the DPWS_CLIENT compile time switch
 *
 * @{
 */

/** @} */

/**
 * @addtogroup APIPeer Peer side API
 * @ingroup DPWSAPI
 *
 *
 * The peer implementation is for endpoints that require both client and device
 * side functionality. This implementation can be activated with the DPWS_PEER
 * switch at compile time.
 *
 * @{
 */

/** @} */

 /** @} */

 /**
 * WS4D utilities
 *
 * @addtogroup WS4D_UTILS WS4D Utilities
 *
 * @{
 */

/** @} */

/**
 * DPWS specific Web Service Modules
 *
 * @addtogroup DPWS_WS_MODULES gSOAP Web Service Modules and Utilities
 *
 * @{
 */

/** @} */
